===== Directory: screens =====
----- File: screens/AboutScreen.js -----
import React from "react";
import { View, Text, ScrollView, StyleSheet } from "react-native";
export default function AboutScreen() {
  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>About Return</Text>
      <Text style={styles.paragraph}>
        Welcome to Return! Our system for character creation and attribute
        management is inspired by Dungeons & Dragons (D&D), but with some key
        differences and simplifications.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Attributes:</Text>
        {"\n"}D&D uses six main attributes (Strength, Dexterity, Constitution,
        Intelligence, Wisdom, Charisma) that influence various aspects of a
        character, such as combat abilities, skills, magic, and resilience.
        {"\n"}Our system uses similar attributes but they are reduced in number
        and have simpler applications. For example, our attributes include
        Strength, Defense, Attack, Speed, Luck, Courage, which is a mix of
        physical and mental characteristics.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Races and Classes:</Text>
        {"\n"}In D&D, a character's race and class have complex interactions
        where the race provides specific bonuses to attributes, and the class
        determines skills, abilities, spells, and hit points (HP). Each
        race-class combination can lead to very different characters with
        various strengths and weaknesses.
        {"\n"}In our system, race and class also provide bonuses to attributes,
        but our classes do not directly affect base attributes (e.g., magic,
        speed). Instead, the class defines the basic role and can influence
        skills and special abilities of the character in a simpler and less
        modular way than in D&D.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Generating Attributes:</Text>
        {"\n"}In D&D, attributes are usually generated by rolling dice (e.g.,
        4d6 and keeping the highest three values), adding an element of
        randomness and imbalance between characters.
        {"\n"}Our system has predefined attribute values based on race and class
        choices. This ensures greater balance and predictability but also limits
        diversity.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Leveling Up:</Text>
        {"\n"}In D&D, as a character levels up, they can increase their
        attributes and gain new abilities, spells, and skills. This process is
        highly detailed, allowing players to customize their characters to suit
        their play style.
        {"\n"}In our system, leveling up would also allow attributes to be
        increased and new abilities to be gained, but likely with less emphasis
        on skills and more on core attributes and simple abilities.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Complexity and Flexibility:</Text>
        {"\n"}D&D is very flexible and complex, allowing players to create and
        customize their characters in various styles and stories. This
        complexity, however, can be challenging for new players.
        {"\n"}Our system is simplified to be more accessible and easier to
        implement. It offers fewer customization options but is also less
        complicated and easier to understand and manage.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Equipment and Spells:</Text>
        {"\n"}In D&D, different types of equipment and spells have very specific
        and varying effects, often with complex rules on how they interact with
        each other.
        {"\n"}Our system likely simplifies equipment and spells, making their
        effects easier to manage and understand.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Conclusion:</Text>
        {"\n"}Our system is simplified and tailored for quick implementation and
        easy use, while D&D is complex and offers much greater depth for
        advanced players who want to customize every aspect of their character.
        The simplifications we have made ensure that the game remains accessible
        and fun without being burdened by too much complexity.
      </Text>
    </ScrollView>
  );
}
const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 20,
  },
  paragraph: {
    fontSize: 16,
    marginBottom: 15,
  },
  subtitle: {
    fontWeight: "bold",
    fontSize: 18,
  },
});


----- File: screens/ActionsMenuScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, Button } from "react-native";
import styles from "../components/styles";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function ActionsMenuScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [characterExists, setCharacterExists] = useState(false);
  useEffect(() => {
    const checkCharacter = async () => {
      try {
        const storedCharacters = await AsyncStorage.getItem("characters");
        console.log("Stored characters:", storedCharacters);
        if (storedCharacters) {
          const characters = JSON.parse(storedCharacters);
          const activeCharacter = characters.find((char) => char.isActive);
          setCharacterExists(!!activeCharacter);
          console.log("Active character exists:", !!activeCharacter);
        } else {
          setCharacterExists(false);
        }
      } catch (error) {
        console.error("Error checking character:", error);
      }
    };
    const updateLocation = async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        console.log("Permission to access location was denied");
        return;
      }
      const loc = await Location.getCurrentPositionAsync({});
      setLocation({
        latitude: loc.coords.latitude,
        longitude: loc.coords.longitude,
      });
    };
    checkCharacter();
    const intervalId = setInterval(updateLocation, 2000);
    return () => clearInterval(intervalId);
  }, []);
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Actions</Text>
      {location ? (
        <Text style={styles.coords}>
          Latitude: {location.latitude.toFixed(6)}
          {"\n"}
          Longitude: {location.longitude.toFixed(6)}
        </Text>
      ) : (
        <Text style={styles.coords}>Loading GPS coordinates...</Text>
      )}
      <View style={styles.buttonContainer}>
        <Button
          title="Place Object"
          onPress={() => navigation.navigate("Place Object")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Search Area"
          onPress={() => navigation.navigate("Search Area")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Inventory"
          onPress={() => navigation.navigate("Inventory")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Tasks"
          onPress={() => navigation.navigate("Tasks")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={characterExists ? "Select Character" : "Create Character"}
          onPress={() => navigation.navigate("CharacterSelection")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
    </View>
  );
}


----- File: screens/BookScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, ScrollView, StyleSheet } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function BookScreen({ navigation }) {
  const [entries, setEntries] = useState([]);
  useEffect(() => {
    const loadEntries = async () => {
      try {
        const storedEntries = await AsyncStorage.getItem("bookEntries");
        const bookEntries = storedEntries ? JSON.parse(storedEntries) : [];
        setEntries(bookEntries);
      } catch (error) {
        console.error("Error loading book entries:", error);
      }
    };
    loadEntries();
  }, []);
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Your Book</Text>
      <ScrollView>
        {entries.length > 0 ? (
          entries.map((entry, index) => (
            <View key={index} style={styles.entryContainer}>
              <Text style={styles.entryTitle}>{entry.name}</Text>
              <Text style={styles.entryText}>{entry.description}</Text>
            </View>
          ))
        ) : (
          <Text style={styles.noEntries}>Your book is empty.</Text>
        )}
      </ScrollView>
      <Button title="Back" onPress={() => navigation.goBack()} />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 16,
    textAlign: "center",
  },
  entryContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
  },
  entryTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 8,
  },
  entryText: {
    fontSize: 16,
  },
  noEntries: {
    fontSize: 18,
    textAlign: "center",
    marginTop: 20,
  },
});


----- File: screens/CharacterCreationScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  TouchableOpacity,
  StyleSheet,
  Modal,
  TextInput,
  TouchableWithoutFeedback,
  Keyboard,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Races } from "../data/Races"; // Opravený import ras
import CharacterClasses from "../data/CharacterClasses"; // Import tříd
import CharacterAttributes from "../data/CharacterAttributes"; // Import atributů
import Character from "../models/Character"; // Import modelu postavy

const CharacterCreationScreen = ({ navigation }) => {
  const [name, setName] = useState("");
  const [selectedRace, setSelectedRace] = useState(null);
  const [selectedGender, setSelectedGender] = useState(null);
  const [selectedClass, setSelectedClass] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [isSelectingRace, setIsSelectingRace] = useState(true);
  const [isSelectingGender, setIsSelectingGender] = useState(false);
  const [isSelectingClass, setIsSelectingClass] = useState(false);
  const [characterAttributes, setCharacterAttributes] = useState({
    strength: 0,
    defense: 0,
    attack: 0,
    speed: 0,
    luck: 0,
    courage: 0,
    mana: 50,
    health: 100,
    level: 1, // Nastavujeme počáteční úroveň postavy
  });

  const handleSelectRace = (race) => {
    if (!race) {
      console.error("Invalid race selected.");
      return;
    }
    setSelectedRace(race);
    setCharacterAttributes({
      strength: race.attributeModifiers.strength || 0,
      defense: race.attributeModifiers.defense || 0,
      attack: race.attributeModifiers.attack || 0,
      speed: race.attributeModifiers.speed || 0,
      luck: race.attributeModifiers.luck || 0,
      courage: race.attributeModifiers.courage || 0,
      magic: race.attributeModifiers.magic || 0,
      mana: 50, // Resetovat mana na základní hodnotu
      health: 100, // Resetovat zdraví na základní hodnotu
      level: 1,
    });
    setIsSelectingRace(false);
    setIsSelectingGender(true);
    setModalVisible(false);
  };

  const handleSelectGender = (gender) => {
    setSelectedGender(gender);
    const genderModifier = CharacterAttributes.genderModifiers[gender] || {};

    // Resetuj hodnoty atributů na základní hodnoty podle vybrané rasy
    const baseAttributes = { ...selectedRace.attributeModifiers };

    // Přičti modifikátory pohlaví
    setCharacterAttributes((prevAttributes) => ({
      strength: baseAttributes.strength + (genderModifier.strength || 0),
      defense: baseAttributes.defense + (genderModifier.defense || 0),
      attack: baseAttributes.attack + (genderModifier.attack || 0),
      speed: baseAttributes.speed + (genderModifier.speed || 0),
      luck: baseAttributes.luck + (genderModifier.luck || 0),
      courage: baseAttributes.courage + (genderModifier.courage || 0),
      magic: baseAttributes.magic + (genderModifier.magic || 0),
      mana: prevAttributes.mana, // Udržet aktuální hodnoty many
      health: prevAttributes.health, // Udržet aktuální hodnoty zdraví
      level: prevAttributes.level,
    }));

    setIsSelectingGender(false);
    setIsSelectingClass(true);
    setModalVisible(false);
  };

  const handleSelectClass = (characterClass) => {
    setSelectedClass(characterClass);
    const classAttributes = CharacterClasses[characterClass];

    // Resetuj hodnoty atributů na základní hodnoty podle vybrané rasy a pohlaví
    const baseAttributes = {
      strength: characterAttributes.strength - (classAttributes.strength || 0),
      defense: characterAttributes.defense - (classAttributes.defense || 0),
      attack: characterAttributes.attack - (classAttributes.attack || 0),
      speed: characterAttributes.speed - (classAttributes.speed || 0),
      luck: characterAttributes.luck - (classAttributes.luck || 0),
      courage: characterAttributes.courage - (classAttributes.courage || 0),
      magic: characterAttributes.magic - (classAttributes.magic || 0),
      mana: characterAttributes.mana,
      health: characterAttributes.health,
      level: characterAttributes.level,
    };

    // Přičti modifikátory povolání
    setCharacterAttributes({
      ...baseAttributes,
      strength: baseAttributes.strength + (classAttributes.strength || 0),
      defense: baseAttributes.defense + (classAttributes.defense || 0),
      attack: baseAttributes.attack + (classAttributes.attack || 0),
      speed: baseAttributes.speed + (classAttributes.speed || 0),
      luck: baseAttributes.luck + (classAttributes.luck || 0),
      courage: baseAttributes.courage + (classAttributes.courage || 0),
      magic: baseAttributes.magic + (classAttributes.magic || 0),
      mana: baseAttributes.mana,
      health: baseAttributes.health,
      level: baseAttributes.level,
    });

    setIsSelectingClass(false);
    setModalVisible(false);
  };

  const handleSaveCharacter = async () => {
    if (!selectedRace || !selectedGender || !selectedClass) {
      alert("Please select a race, gender, and class.");
      return;
    }

    const newCharacter = new Character(
      name,
      selectedRace.name, // Přenese jméno rasy
      selectedClass,
      selectedGender,
      [], // naturalTalents
      [], // abilities
      [] // inventory
    );

    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      const characters = storedCharacters ? JSON.parse(storedCharacters) : [];
      characters.push(newCharacter);
      await AsyncStorage.setItem("characters", JSON.stringify(characters));
      navigation.navigate("CharacterSelection");
    } catch (error) {
      console.error("Failed to save character", error);
      alert("There was an error saving the character.");
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <Text style={styles.label}>Character Name:</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Enter character name"
        />
        <View style={styles.buttonSpacing}>
          <Button
            title="Select Race"
            onPress={() => {
              setIsSelectingRace(true);
              setModalVisible(true);
            }}
          />
        </View>
        {selectedRace && (
          <>
            <View style={styles.detailsContainer}>
              <Text>Selected Race: {selectedRace.name}</Text>
              <Text>Description: {selectedRace.description}</Text>
              <Text>Strength: {characterAttributes.strength}</Text>
              <Text>Defense: {characterAttributes.defense}</Text>
              <Text>Attack: {characterAttributes.attack}</Text>
              <Text>Speed: {characterAttributes.speed}</Text>
              <Text>Luck: {characterAttributes.luck}</Text>
              <Text>Courage: {characterAttributes.courage}</Text>
              <Text>Health: {characterAttributes.health}</Text>
              <Text>Mana: {characterAttributes.mana}</Text>
            </View>
            <View style={styles.buttonSpacing}>
              <Button
                title="Select Gender"
                onPress={() => {
                  setIsSelectingGender(true);
                  setModalVisible(true);
                }}
              />
            </View>
          </>
        )}
        {selectedGender && (
          <>
            <View style={styles.detailsContainer}>
              <Text>Selected Gender: {selectedGender}</Text>
            </View>
            <View style={styles.buttonSpacing}>
              <Button
                title="Select Class"
                onPress={() => {
                  setIsSelectingClass(true);
                  setModalVisible(true);
                }}
              />
            </View>
          </>
        )}
        {selectedClass && (
          <View style={styles.detailsContainer}>
            <Text>Selected Class: {selectedClass}</Text>
          </View>
        )}
        <View style={styles.buttonSpacing}>
          <Button title="Save Character" onPress={handleSaveCharacter} />
        </View>
        <Modal
          animationType="slide"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => setModalVisible(false)}
        >
          <View style={styles.modalView}>
            {isSelectingRace
              ? Object.values(Races).map((race) => (
                  <TouchableOpacity
                    key={race.name}
                    style={styles.modalItem}
                    onPress={() => handleSelectRace(race)}
                  >
                    <Text>{race.name}</Text>
                  </TouchableOpacity>
                ))
              : isSelectingGender
              ? ["Male", "Female"].map((gender) => (
                  <TouchableOpacity
                    key={gender}
                    style={styles.modalItem}
                    onPress={() => handleSelectGender(gender)}
                  >
                    <Text>{gender}</Text>
                  </TouchableOpacity>
                ))
              : Object.keys(CharacterClasses).map((characterClass) => (
                  <TouchableOpacity
                    key={characterClass}
                    style={styles.modalItem}
                    onPress={() => handleSelectClass(characterClass)}
                  >
                    <Text>{characterClass}</Text>
                  </TouchableOpacity>
                ))}
            <Button title="Cancel" onPress={() => setModalVisible(false)} />
          </View>
        </Modal>
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  detailsContainer: {
    marginTop: 16,
  },
  buttonSpacing: {
    marginVertical: 10,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});

export default CharacterCreationScreen;


----- File: screens/CharacterDetailScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  Alert,
  ScrollView,
} from "react-native";
export default function CharacterDetailScreen({ route }) {
  const { character } = route.params;
  const [inventory, setInventory] = useState(
    initializeInventory(character.inventory)
  );
  function initializeInventory(inventory = {}) {
    return {
      head: inventory.head || null,
      neck: inventory.neck || null,
      body: inventory.body || null,
      hands: inventory.hands || [null, null],
      legs: inventory.legs || null,
      feet: inventory.feet || null,
      fingers: inventory.fingers || Array(10).fill(null),
      items: inventory.items || [],
    };
  }
  const handleUnequipItem = (slot, index = null) => {
    const updatedInventory = { ...inventory };
    if (index !== null) {
      updatedInventory[slot][index] = null;
    } else {
      updatedInventory[slot] = null;
    }
    setInventory(updatedInventory);
    Alert.alert("Item removed", `The item from ${slot} was unequipped.`);
  };
  const handleEquipItem = (item, slot, index = null) => {
    if (!slot) {
      Alert.alert("Cannot Equip", "This item cannot be equipped to any slot.");
      return;
    }
    const updatedInventory = { ...inventory };
    if (index !== null) {
      updatedInventory[slot][index] = item;
    } else {
      updatedInventory[slot] = item;
    }
    setInventory(updatedInventory);
    Alert.alert("Item equipped", `${item.name} was equipped to ${slot}.`);
  };
  const renderEquippedItem = (slot, label, index = null) => {
    const item = index !== null ? inventory[slot][index] : inventory[slot];
    return (
      <View style={styles.itemSlot}>
        <Text style={styles.itemSlotText}>
          {label}: {item ? item.name : "None"}
        </Text>
        {item && (
          <Button
            title="Remove"
            onPress={() => handleUnequipItem(slot, index)}
          />
        )}
      </View>
    );
  };
  return (
    <ScrollView contentContainerStyle={styles.scrollContainer}>
      <View style={styles.container}>
        <Text style={styles.title}>{character.name}</Text>
        <Text>Race: {character.race}</Text>
        <Text>Class: {character.characterClass}</Text>
        <Text>Level: {character.level}</Text>
        <Text>Health: {character.health}</Text>
        <Text>Mana: {character.mana}</Text>
        <Text style={styles.sectionTitle}>Equipped Items:</Text>
        {renderEquippedItem("head", "Head")}
        {renderEquippedItem("neck", "Neck")}
        {renderEquippedItem("body", "Body")}
        {renderEquippedItem("hands", "Left Hand", 0)}
        {renderEquippedItem("hands", "Right Hand", 1)}
        {renderEquippedItem("legs", "Legs")}
        {renderEquippedItem("feet", "Feet")}
        {inventory.fingers.map((ring, index) => (
          <View key={index}>
            {renderEquippedItem("fingers", `Finger (${index + 1})`, index)}
          </View>
        ))}
        <Text style={styles.sectionTitle}>Inventory:</Text>
        {inventory.items.map((item) => (
          <View key={item.id} style={styles.inventoryItem}>
            <Text>{item.name}</Text>
            <Button
              title="Equip"
              onPress={() => handleEquipItem(item, item.slot)}
            />
          </View>
        ))}
      </View>
    </ScrollView>
  );
}
const styles = StyleSheet.create({
  scrollContainer: {
    paddingBottom: 20, // Přidání spodního paddingu pro posuvnost
  },
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
  },
  sectionTitle: {
    fontSize: 20,
    marginTop: 20,
    marginBottom: 10,
    fontWeight: "bold",
  },
  itemSlot: {
    marginBottom: 20,
  },
  itemSlotText: {
    fontSize: 18,
    marginBottom: 10,
  },
  inventoryItem: {
    marginBottom: 10,
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 10,
    borderRadius: 5,
  },
});


----- File: screens/CharacterEquipmentScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Alert,
} from "react-native";
export default function CharacterEquipmentScreen({ route }) {
  const { character } = route.params;
  const [inventory, setInventory] = useState(
    initializeInventory(character.inventory)
  );
  const [selectedSlot, setSelectedSlot] = useState(null);
  function initializeInventory(inventory = {}) {
    return {
      head: inventory.head || null,
      neck: inventory.neck || null,
      body: inventory.body || null,
      hands: inventory.hands || [null, null],
      legs: inventory.legs || null,
      feet: inventory.feet || null,
      fingers: inventory.fingers || Array(10).fill(null),
      items: inventory.items || [],
    };
  }
  const handleEquipItem = (item) => {
    const updatedInventory = { ...inventory };
    if (selectedSlot.index !== null) {
      updatedInventory[selectedSlot.slot][selectedSlot.index] = item;
    } else {
      updatedInventory[selectedSlot.slot] = item;
    }
    setInventory(updatedInventory);
    setSelectedSlot(null);
    Alert.alert(
      "Item equipped",
      `${item.name} was equipped to ${selectedSlot.label}.`
    );
  };
  const renderSlot = (label, slot, index = null) => {
    const item = index !== null ? inventory[slot][index] : inventory[slot];
    return (
      <TouchableOpacity
        style={styles.slot}
        onPress={() => setSelectedSlot({ slot, index, label })}
      >
        <Text style={styles.slotLabel}>{label}</Text>
        <Text>{item ? item.name : "None"}</Text>
      </TouchableOpacity>
    );
  };
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{character.name}</Text>
      <Text>Level: {character.level}</Text>
      {/* Vizuální zobrazení těla */}
      <View style={styles.bodyContainer}>
        <View style={styles.upperBody}>
          {renderSlot("Head", "head")}
          {renderSlot("Neck", "neck")}
          {renderSlot("Body", "body")}
        </View>
        <View style={styles.hands}>
          {renderSlot("Left Hand", "hands", 0)}
          {renderSlot("Right Hand", "hands", 1)}
        </View>
        <View style={styles.lowerBody}>
          {renderSlot("Legs", "legs")}
          {renderSlot("Feet", "feet")}
        </View>
      </View>
      {/* Inventář pro vybavení */}
      {selectedSlot && (
        <View style={styles.inventoryContainer}>
          <Text>Equip item to {selectedSlot.label}:</Text>
          <FlatList
            data={inventory.items}
            keyExtractor={(item) => item.id.toString()}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.inventoryItem}
                onPress={() => handleEquipItem(item)}
              >
                <Text>{item.name}</Text>
              </TouchableOpacity>
            )}
          />
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#f5f5f5",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 16,
  },
  bodyContainer: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  upperBody: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "80%",
  },
  hands: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    marginTop: 20,
  },
  lowerBody: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "80%",
    marginTop: 20,
  },
  slot: {
    alignItems: "center",
    justifyContent: "center",
    padding: 10,
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 5,
    backgroundColor: "#fff",
    marginVertical: 5,
  },
  slotLabel: {
    fontWeight: "bold",
  },
  inventoryContainer: {
    padding: 16,
    backgroundColor: "#fff",
    borderTopWidth: 1,
    borderColor: "#ccc",
  },
  inventoryItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderColor: "#ccc",
  },
});


----- File: screens/CharacterSelectionScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
const CharacterSelectionScreen = ({ navigation }) => {
  const [characters, setCharacters] = useState([]);
  const [activeCharacter, setActiveCharacter] = useState(null);
  useEffect(() => {
    const unsubscribe = navigation.addListener("focus", () => {
      loadCharacters();
    });
    return unsubscribe;
  }, [navigation]);
  const loadCharacters = async () => {
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      if (storedCharacters) {
        const parsedCharacters = JSON.parse(storedCharacters);
        setCharacters(parsedCharacters);
        const activeChar = parsedCharacters.find((char) => char.isActive);
        setActiveCharacter(activeChar);
      }
    } catch (error) {
      console.error("Failed to load characters", error);
    }
  };
  const selectCharacter = async (character) => {
    // Označení vybrané postavy jako aktivní
    const updatedCharacters = characters.map((char) => ({
      ...char,
      isActive: char.name === character.name,
    }));
    setCharacters(updatedCharacters);
    await AsyncStorage.setItem("characters", JSON.stringify(updatedCharacters));
    setActiveCharacter(character);
    console.log("Selected character:", character);
    navigation.navigate("CharacterDetail", { character }); // Předání vybrané postavy do CharacterDetailScreen
  };
  const createCharacter = () => {
    // Přesměrování na obrazovku pro vytvoření postavy
    navigation.navigate("CharacterCreation");
  };
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Select Your Character</Text>
      {characters.length > 0 ? (
        <FlatList
          data={characters}
          keyExtractor={(item, index) => index.toString()}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={[
                styles.characterItem,
                item.isActive && styles.activeCharacterItem,
              ]}
              onPress={() => selectCharacter(item)}
            >
              <Text>
                {item.name} - {item.characterClass}{" "}
                {item.isActive ? "(Active)" : ""}
              </Text>
            </TouchableOpacity>
          )}
        />
      ) : (
        <View style={styles.noCharacterContainer}>
          <Text style={styles.noCharacterText}>No characters found.</Text>
          <Button title="Create Character" onPress={createCharacter} />
        </View>
      )}
      <Button title="Back" onPress={() => navigation.goBack()} />
    </View>
  );
};
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 20,
    textAlign: "center",
  },
  characterItem: {
    padding: 10,
    marginVertical: 8,
    backgroundColor: "#f9f9f9",
    borderColor: "#ddd",
    borderWidth: 1,
    borderRadius: 5,
  },
  activeCharacterItem: {
    backgroundColor: "#d0f0c0", // Zelenější barva pro označení aktivní postavy
  },
  noCharacterContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  noCharacterText: {
    fontSize: 18,
    marginBottom: 20,
  },
});
export default CharacterSelectionScreen;


----- File: screens/CharacterSettingsScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Alert,
  Modal,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function CharacterSettingsScreen({ navigation }) {
  const [name, setName] = useState("");
  const [characterClass, setCharacterClass] = useState("Warrior");
  const [characterList, setCharacterList] = useState([]);
  const [modalVisible, setModalVisible] = useState(false);
  useEffect(() => {
    loadCharacters();
  }, []);
  const loadCharacters = async () => {
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      if (storedCharacters) {
        setCharacterList(JSON.parse(storedCharacters));
      }
    } catch (error) {
      console.error("Failed to load characters", error);
    }
  };
  const saveCharacter = async () => {
    try {
      const newCharacter = { name, characterClass };
      const updatedCharacterList = [...characterList, newCharacter];
      setCharacterList(updatedCharacterList);
      await AsyncStorage.setItem(
        "characters",
        JSON.stringify(updatedCharacterList)
      );
      Alert.alert("Success", "Character saved!");
    } catch (error) {
      console.error("Failed to save character", error);
      Alert.alert("Error", "Failed to save character");
    }
  };
  const deleteCharacter = async (index) => {
    try {
      const updatedCharacterList = characterList.filter((_, i) => i !== index);
      setCharacterList(updatedCharacterList);
      await AsyncStorage.setItem(
        "characters",
        JSON.stringify(updatedCharacterList)
      );
      Alert.alert("Success", "Character deleted!");
    } catch (error) {
      console.error("Failed to delete character", error);
      Alert.alert("Error", "Failed to delete character");
    }
  };
  const characterClasses = ["Warrior", "Mage", "Rogue"]; // Přidat další třídy podle potřeby
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Character Settings</Text>
      <TextInput
        style={styles.input}
        placeholder="Character Name"
        value={name}
        onChangeText={setName}
      />
      <Text style={styles.label}>Class</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setModalVisible(true)}
      >
        <Text>{characterClass}</Text>
      </TouchableOpacity>
      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => {
          setModalVisible(!modalVisible);
        }}
      >
        <View style={styles.modalView}>
          {characterClasses.map((item) => (
            <TouchableOpacity
              key={item}
              style={styles.modalItem}
              onPress={() => {
                setCharacterClass(item);
                setModalVisible(false);
              }}
            >
              <Text>{item}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setModalVisible(false)} />
        </View>
      </Modal>
      <Button title="Save Character" onPress={saveCharacter} />
      {characterList.length > 0 && (
        <View style={styles.characterList}>
          <Text style={styles.label}>Your Characters:</Text>
          {characterList.map((character, index) => (
            <View key={index} style={styles.characterItem}>
              <Text>
                {character.name} - {character.characterClass}
              </Text>
              <Button title="Delete" onPress={() => deleteCharacter(index)} />
            </View>
          ))}
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 20,
    textAlign: "center",
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  label: {
    marginBottom: 10,
    fontSize: 16,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
  characterList: {
    marginTop: 20,
  },
  characterItem: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 10,
  },
});


----- File: screens/CharacterSetupScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Modal,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import Races from "../data/Races";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character";
export default function CharacterSetupScreen({ navigation }) {
  const [name, setName] = useState("");
  const [characterClass, setCharacterClass] = useState("Warrior");
  const [selectedRace, setSelectedRace] = useState("Human");
  const [raceModalVisible, setRaceModalVisible] = useState(false); // Samostatný stav pro modální okno rasy
  const [classModalVisible, setClassModalVisible] = useState(false); // Samostatný stav pro modální okno povolání
  const characterClasses = ["Warrior", "Mage", "Rogue"];
  const raceNames = Object.keys(Races);
  const handleSaveCharacter = async () => {
    const newCharacter = new Character(
      name,
      selectedRace,
      characterClass,
      [], // Natural talents
      [], // Abilities
      [] // Inventory
    );
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      const characters = storedCharacters ? JSON.parse(storedCharacters) : [];
      characters.push(newCharacter);
      await AsyncStorage.setItem("characters", JSON.stringify(characters));
      alert("Character created successfully!");
      navigation.navigate("CharacterSelection");
    } catch (error) {
      console.error("Failed to save character", error);
      alert("There was an error saving the character.");
    }
  };
  return (
    <View style={styles.container}>
      <Text style={styles.label}>Character Name:</Text>
      <TextInput
        style={styles.input}
        value={name}
        onChangeText={setName}
        placeholder="Enter character name"
      />
      <Text style={styles.label}>Race:</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setRaceModalVisible(true)} // Zobrazení modálního okna rasy
      >
        <Text>{selectedRace}</Text>
      </TouchableOpacity>
      <Modal
        animationType="slide"
        transparent={true}
        visible={raceModalVisible}
        onRequestClose={() => setRaceModalVisible(!raceModalVisible)}
      >
        <View style={styles.modalView}>
          {raceNames.map((race) => (
            <TouchableOpacity
              key={race}
              style={styles.modalItem}
              onPress={() => {
                setSelectedRace(race);
                setRaceModalVisible(false);
              }}
            >
              <Text>{race}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setRaceModalVisible(false)} />
        </View>
      </Modal>
      <Text style={styles.label}>Character Class:</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setClassModalVisible(true)} // Zobrazení modálního okna povolání
      >
        <Text>{characterClass}</Text>
      </TouchableOpacity>
      <Modal
        animationType="slide"
        transparent={true}
        visible={classModalVisible}
        onRequestClose={() => setClassModalVisible(!classModalVisible)}
      >
        <View style={styles.modalView}>
          {characterClasses.map((item) => (
            <TouchableOpacity
              key={item}
              style={styles.modalItem}
              onPress={() => {
                setCharacterClass(item);
                setClassModalVisible(false);
              }}
            >
              <Text>{item}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setClassModalVisible(false)} />
        </View>
      </Modal>
      <Button title="Save Character" onPress={handleSaveCharacter} />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});


----- File: screens/CurrentLocationMapScreen.js -----
import React, { useState, useEffect, useRef } from "react";
import {
  View,
  StyleSheet,
  Text,
  Image,
  TouchableOpacity,
  Alert,
  Button,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import GMapModule from "../components/GMapModule";
import * as Location from "expo-location";
export default function CurrentLocationMapScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [points, setPoints] = useState([]);
  const [returnPoint, setReturnPoint] = useState(null);
  const [selectedPointData, setSelectedPointData] = useState(null);
  const [distanceToSelected, setDistanceToSelected] = useState(null);
  const [currentIndex, setCurrentIndex] = useState(0);
  const mapCenterRef = useRef(() => {});
  useEffect(() => {
    const getLocationAndPoints = async () => {
      try {
        let { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== "granted") {
          Alert.alert(
            "Permission denied",
            "Permission to access location was denied"
          );
          return;
        }
        let location = await Location.getCurrentPositionAsync({});
        setLocation(location.coords);
        const storedPoints = await AsyncStorage.getItem("interestPoints");
        if (storedPoints) {
          const parsedPoints = JSON.parse(storedPoints);
          setPoints(parsedPoints);
        }
        const storedReturnPoint = await AsyncStorage.getItem("returnPoint");
        if (storedReturnPoint) {
          const parsedReturnPoint = JSON.parse(storedReturnPoint);
          setReturnPoint(parsedReturnPoint);
        }
      } catch (error) {
        Alert.alert("Error", "Error getting location or loading points");
        console.error("Error getting location or loading points: ", error);
      }
    };
    getLocationAndPoints();
  }, []);
  const handleMarkerClick = (index, point) => {
    setSelectedPointData(point);
    setCurrentIndex(index);
    if (location) {
      const distance = calculateDistance(
        location.latitude,
        location.longitude,
        point.location.latitude,
        point.location.longitude
      );
      setDistanceToSelected(distance);
    }
    // Zavolání metody pro nastavení středu mapy
    mapCenterRef.current(point.location.latitude, point.location.longitude);
  };
  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3;
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };
  const handlePreviousPoint = () => {
    if (points.length > 0) {
      const prevIndex = (currentIndex - 1 + points.length) % points.length;
      handleMarkerClick(prevIndex, points[prevIndex]);
    }
  };
  const handleNextPoint = () => {
    if (points.length > 0) {
      const nextIndex = (currentIndex + 1) % points.length;
      handleMarkerClick(nextIndex, points[nextIndex]);
    }
  };
  const handleNavigate = () => {
    if (selectedPointData) {
      navigation.navigate("KompasScreen", { point: selectedPointData });
    }
  };
  const handleCancel = () => {
    setSelectedPointData(null);
    setDistanceToSelected(null);
  };
  return (
    <View style={styles.container}>
      <GMapModule
        points={points}
        returnPoint={returnPoint}
        onMarkerClick={handleMarkerClick}
        setMapCenter={(func) => (mapCenterRef.current = func)}
      />
      {selectedPointData && (
        <View style={styles.infoBox}>
          <View style={styles.infoRow}>
            {selectedPointData.image && (
              <Image
                source={{ uri: selectedPointData.image }}
                style={styles.image}
              />
            )}
            <View style={styles.infoDetails}>
              <Text style={styles.infoText}>
                {selectedPointData.description}
              </Text>
              <Text style={styles.infoText}>
                Souřadnice: {selectedPointData.location.latitude.toFixed(6)},{" "}
                {selectedPointData.location.longitude.toFixed(6)}
              </Text>
              {distanceToSelected && (
                <Text style={styles.infoText}>
                  Vzdálenost: {(distanceToSelected / 1000).toFixed(2)} km
                </Text>
              )}
            </View>
          </View>
          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={styles.button}
              onPress={handlePreviousPoint}
            >
              <Text style={styles.buttonText}>←</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.button} onPress={handleNextPoint}>
              <Text style={styles.buttonText}>→</Text>
            </TouchableOpacity>
          </View>
          <View style={styles.buttonContainer}>
            <Button title="Navigate" onPress={handleNavigate} />
            <Button title="Cancel" onPress={handleCancel} />
          </View>
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  infoBox: {
    position: "absolute",
    bottom: 20,
    left: 10,
    right: 10,
    backgroundColor: "white",
    padding: 15,
    borderRadius: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    elevation: 5,
  },
  infoRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  infoDetails: {
    flex: 1,
    paddingLeft: 10,
  },
  infoText: {
    fontSize: 14,
    marginBottom: 5,
  },
  image: {
    width: 80,
    height: 80,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 10,
  },
  button: {
    backgroundColor: "#007bff",
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 5,
  },
  buttonText: {
    color: "white",
    fontWeight: "bold",
    textAlign: "center",
  },
});


----- File: screens/DungeonScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, Button, Alert } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character";
import { generateEnemy } from "../utils/generateEnemy";
import standartItems from "../data/standardItems"; // Import standardních položek

const DungeonScreen = ({ route, navigation }) => {
  const { dungeon } = route.params;
  const [character, setCharacter] = useState(null);
  const [enemies, setEnemies] = useState([]);
  const [playerPower, setPlayerPower] = useState(0);
  const [enemyPower, setEnemyPower] = useState(0);
  const [reward, setReward] = useState({ gold: 0, items: [] });

  useEffect(() => {
    const fetchCharacterAndGenerateEnemies = async () => {
      try {
        const storedCharacter = await AsyncStorage.getItem("activeCharacter");
        if (!storedCharacter) {
          throw new Error("Character data not found.");
        }

        const parsedCharacter = JSON.parse(storedCharacter);
        const characterInstance = new Character(
          parsedCharacter.name,
          parsedCharacter.race,
          parsedCharacter.characterClass,
          parsedCharacter.naturalTalents,
          parsedCharacter.abilities,
          parsedCharacter.inventory
        );
        setCharacter(characterInstance);

        const generatedEnemies = [];
        for (let i = 0; i < 3; i++) {
          const enemy = generateEnemy(
            characterInstance.level,
            dungeon.difficulty || "normal",
            dungeon.environment
          );
          generatedEnemies.push(enemy);
        }
        setEnemies(generatedEnemies);

        const playerTotalPower = characterInstance.calculatePower();
        const enemyTotalPower = generatedEnemies.reduce(
          (acc, enemy) => acc + enemy.attack + enemy.defense,
          0
        );

        setPlayerPower(playerTotalPower);
        setEnemyPower(enemyTotalPower);
        calculateReward(playerTotalPower, enemyTotalPower, generatedEnemies);
      } catch (error) {
        console.error("Failed to fetch character or generate enemies", error);
        Alert.alert("Error", "Failed to fetch character or generate enemies");
      }
    };

    fetchCharacterAndGenerateEnemies();
  }, [dungeon]);

  const calculateReward = (playerPower, enemyPower, enemies) => {
    let rewardValue;
    let rewardItems = [];

    if (playerPower > enemyPower) {
      rewardValue = Math.floor(Math.random() * 50) + 50;

      // Přidání náhodného předmětu z standartItems
      const itemTypes = Object.keys(standartItems);
      const randomType =
        itemTypes[Math.floor(Math.random() * itemTypes.length)];
      const randomItem =
        standartItems[randomType][
          Math.floor(Math.random() * standartItems[randomType].length)
        ];
      rewardItems.push(randomItem);

      // Přidání vybavení z nepřátel
      enemies.forEach((enemy) => {
        if (enemy.weapon) rewardItems.push(enemy.weapon);
        if (enemy.armor) rewardItems.push(enemy.armor);
      });
    } else {
      rewardValue = Math.floor(Math.random() * 20) + 10;
    }

    setReward({ gold: rewardValue, items: rewardItems });
  };

  const startExploration = () => {
    let message = `You encountered ${enemies.length} enemies with a total power of ${enemyPower}. Your total power is ${playerPower}.`;

    if (reward.items.length > 0) {
      const itemNames = reward.items.map((item) => item.name).join(", ");
      message += ` You also found: ${itemNames}.`;
    }

    Alert.alert("Dungeon Exploration", message, [
      {
        text: "Fight",
        onPress: async () => {
          if (playerPower > enemyPower) {
            const victoryMessage = `You defeated the enemies, earned ${
              reward.gold
            } gold, and found: ${reward.items
              .map((item) => item.name)
              .join(", ")}!`;

            Alert.alert("Victory!", victoryMessage);
            reward.items.forEach((item) => {
              character.addItemToInventory(item);
            });
            await AsyncStorage.setItem(
              "activeCharacter",
              JSON.stringify(character)
            );
          } else {
            Alert.alert(
              "Defeat!",
              "You were defeated and escaped with nothing."
            );
          }
          navigation.navigate("CharacterSelection");
        },
      },
      {
        text: "Flee",
        onPress: () => navigation.navigate("CharacterSelection"),
      },
    ]);
  };

  return (
    <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>{dungeon.name}</Text>
      <Text style={{ fontSize: 16, marginVertical: 10 }}>
        {dungeon.description}
      </Text>
      <Button title="Start Exploration" onPress={startExploration} />
    </View>
  );
};

export default DungeonScreen;


----- File: screens/EditPointScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  StyleSheet,
  Alert,
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function EditPointScreen({ route, navigation }) {
  const { point } = route.params;
  const [description, setDescription] = useState(point.description || "");
  const [detailedDescription, setDetailedDescription] = useState(
    point.detailedDescription || ""
  );
  const [latitude, setLatitude] = useState(
    point.location.latitude?.toString() || ""
  );
  const [longitude, setLongitude] = useState(
    point.location.longitude?.toString() || ""
  );
  const handleSave = async () => {
    try {
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      let points = storedPoints ? JSON.parse(storedPoints) : [];
      const index = points.findIndex((p) => p.title === point.title);
      if (index !== -1) {
        points[index].description = description;
        points[index].detailedDescription = detailedDescription;
        points[index].location.latitude = parseFloat(latitude);
        points[index].location.longitude = parseFloat(longitude);
        await AsyncStorage.setItem("interestPoints", JSON.stringify(points));
        Alert.alert("Success", "Point updated successfully.");
        navigation.goBack();
      }
    } catch (error) {
      console.error("Error saving point:", error);
      Alert.alert("Error", "There was an error updating the point.");
    }
  };
  const movePoint = (direction) => {
    const distance = 0.0001; // Přibližně 11 metrů
    switch (direction) {
      case "north":
        setLatitude((parseFloat(latitude) + distance).toString());
        break;
      case "south":
        setLatitude((parseFloat(latitude) - distance).toString());
        break;
      case "east":
        setLongitude((parseFloat(longitude) + distance).toString());
        break;
      case "west":
        setLongitude((parseFloat(longitude) - distance).toString());
        break;
      default:
        break;
    }
  };
  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={80}
    >
      <ScrollView contentContainerStyle={styles.scrollViewContainer}>
        <Text style={styles.label}>Description:</Text>
        <TextInput
          style={styles.input}
          value={description}
          onChangeText={setDescription}
        />
        <Text style={styles.label}>Detailed Description:</Text>
        <TextInput
          style={[styles.input, { height: 100 }]}
          value={detailedDescription}
          onChangeText={setDetailedDescription}
          multiline
        />
        <Text style={styles.label}>
          Latitude: {latitude || "Not available"}
        </Text>
        <Text style={styles.label}>
          Longitude: {longitude || "Not available"}
        </Text>
        <View style={styles.buttonContainer}>
          <Button title="Move North" onPress={() => movePoint("north")} />
          <Button title="Move South" onPress={() => movePoint("south")} />
          <Button title="Move East" onPress={() => movePoint("east")} />
          <Button title="Move West" onPress={() => movePoint("west")} />
        </View>
        {point.image && (
          <Image source={{ uri: point.image }} style={styles.image} />
        )}
        <Button title="Save" onPress={handleSave} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollViewContainer: {
    padding: 16,
    flexGrow: 1,
    justifyContent: "space-between",
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 8,
    marginBottom: 16,
    fontSize: 16,
    borderRadius: 4,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 16,
  },
  image: {
    width: 100,
    height: 100,
    marginBottom: 16,
    alignSelf: "center",
  },
});


----- File: screens/EquipmentScreen.js -----
import React from "react";
import { View, Text, Button, StyleSheet, Alert } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function EquipmentScreen({ character, setCharacter }) {
  const handleUnequipItem = async (slot) => {
    const item = character.inventory[slot];
    if (item) {
      Alert.alert("Unequip Item", `Opravdu chcete odvybavit ${item.name}?`, [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Odvybavit",
          onPress: async () => {
            // Remove item from the equipped slot
            const newInventory = [...character.inventory.items];
            newInventory.push({ ...item, equipped: false });
            const updatedCharacter = {
              ...character,
              inventory: {
                ...character.inventory,
                [slot]: null,
                items: newInventory,
              },
            };
            setCharacter(updatedCharacter);
            await AsyncStorage.setItem(
              "character",
              JSON.stringify(updatedCharacter)
            );
            Alert.alert(`${item.name} byl odvybaven a přesunut do inventáře.`);
          },
        },
      ]);
    }
  };
  const renderEquippedItem = (slot, label) => {
    const item = character.inventory[slot];
    if (!item) {
      return <Text style={styles.itemSlotText}>{label}: Žádný předmět</Text>;
    }
    let itemDetails = "";
    switch (item.type) {
      case "weapon":
        itemDetails = `Útok: +${item.properties.attackPoints}`;
        break;
      case "armor":
        itemDetails = `Obrana: +${item.properties.defensePoints}`;
        break;
      case "ring":
      case "amulet":
        itemDetails = `Efekt: +${item.properties.effectAmount}`;
        break;
      default:
        itemDetails = "";
    }
    return (
      <View style={styles.itemSlot}>
        <Text style={styles.itemSlotText}>
          {label}: {item.name} ({itemDetails})
        </Text>
        <Button title="Odvybavit" onPress={() => handleUnequipItem(slot)} />
      </View>
    );
  };
  return (
    <View style={styles.container}>
      {renderEquippedItem("head", "Hlava")}
      {renderEquippedItem("neck", "Krk")}
      {renderEquippedItem("body", "Tělo")}
      {renderEquippedItem("hands[0]", "Levá ruka")}
      {renderEquippedItem("hands[1]", "Pravá ruka")}
      {renderEquippedItem("legs", "Nohy")}
      {renderEquippedItem("feet", "Chodidla")}
      {character.inventory.fingers.map((ring, index) => (
        <View key={index}>
          {renderEquippedItem(`fingers[${index}]`, `Prst (${index + 1})`)}
        </View>
      ))}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#f5f5f5",
  },
  itemSlot: {
    marginBottom: 20,
  },
  itemSlotText: {
    fontSize: 18,
    marginBottom: 10,
  },
});


----- File: screens/HomeScreen.js -----
import React, { useEffect, useState } from "react";
import { View, Text, Button, Alert, ImageBackground } from "react-native";
import styles from "../components/styles"; // Importování stylů
import { useFocusEffect } from "@react-navigation/native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function HomeScreen({ navigation }) {
  const [returnPointSet, setReturnPointSet] = useState(false);
  const [characterSummary, setCharacterSummary] = useState(null);
  useFocusEffect(
    React.useCallback(() => {
      checkReturnPoint();
      loadCharacterSummary();
    }, [])
  );
  const checkReturnPoint = async () => {
    try {
      const returnPoint = await AsyncStorage.getItem("returnPoint");
      setReturnPointSet(!!returnPoint);
    } catch (error) {
      console.error("Error reading return point from AsyncStorage:", error);
      setReturnPointSet(false);
    }
  };
  const loadCharacterSummary = async () => {
    try {
      const storedCharacter = await AsyncStorage.getItem("characters");
      if (storedCharacter) {
        const character = JSON.parse(storedCharacter)[0]; // Zobrazí se první postava
        setCharacterSummary({
          name: character.name,
          race: character.race,
          gender: character.gender || "", // Pokud není gender definován, nastaví se na prázdný řetězec
          characterClass: character.characterClass,
          level: character.level || 1,
        });
      }
    } catch (error) {
      console.error("Failed to load character summary", error);
    }
  };
  const setReturnPoint = async () => {
    showConfirmationDialog(
      "Set Return Point?",
      "Do you really want to set this location as your return point?",
      async () => {
        try {
          let { status } = await Location.requestForegroundPermissionsAsync();
          if (status !== "granted") {
            Alert.alert("Permission Denied", "Access to location was denied.");
            return;
          }
          let currentLocation = await Location.getCurrentPositionAsync({});
          const returnPoint = {
            latitude: currentLocation.coords.latitude,
            longitude: currentLocation.coords.longitude,
            title: "Return Point",
          };
          await AsyncStorage.setItem(
            "returnPoint",
            JSON.stringify(returnPoint)
          );
          console.log("Return point saved:", returnPoint);
          setReturnPointSet(true);
          Alert.alert("Saved", "Return point successfully saved!");
          navigation.navigate("Home");
        } catch (error) {
          console.error("Error setting return point:", error);
          Alert.alert("Error", "There was an error setting the return point.");
        }
      }
    );
  };
  const showConfirmationDialog = (title, message, onConfirm) => {
    Alert.alert(
      title,
      message,
      [
        {
          text: "Cancel",
          style: "cancel",
        },
        {
          text: "Yes",
          onPress: onConfirm,
        },
      ],
      { cancelable: true }
    );
  };
  return (
    <ImageBackground
      source={require("../assets/return.png")}
      style={styles.container}
    >
      <View style={styles.textContainer}>
        <Text style={[styles.title, { color: "#fff", fontSize: 28 }]}>
          Explore, Capture, and Never Get Lost Again
        </Text>
        <Text style={[styles.subtitle, { color: "#fff", fontSize: 20 }]}>
          Your personal map for mushroom hunting and other adventures
        </Text>
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Set Return Point"
          onPress={setReturnPoint}
          disabled={returnPointSet}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Record Interest Point"
          onPress={() => navigation.navigate("Interest Point")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Actions"
          onPress={() => navigation.navigate("Actions Menu")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Map"
          onPress={() => navigation.navigate("DynamicMap")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Photos"
          onPress={() => navigation.navigate("Photo Viewer")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Settings"
          onPress={() => navigation.navigate("Settings")}
        />
      </View>
      {/* Zobrazení souhrnu postavy */}
      {characterSummary && (
        <View style={{ marginTop: 20 }}>
          <Text style={{ color: "#fff", fontSize: 18, textAlign: "center" }}>
            {characterSummary.name} {characterSummary.race}{" "}
            {characterSummary.gender ? characterSummary.gender.charAt(0) : ""}{" "}
            {characterSummary.characterClass} Lvl {characterSummary.level}
          </Text>
        </View>
      )}
    </ImageBackground>
  );
}


----- File: screens/InterestPointScreen.js -----
import React, { useState } from "react";
import * as FileSystem from "expo-file-system";
import {
  View,
  Text,
  Button,
  StyleSheet,
  Image,
  TextInput,
  Alert,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import * as Location from "expo-location";
import * as ImagePicker from "expo-image-picker";
import * as ImageManipulator from "expo-image-manipulator";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function InterestPointScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [image, setImage] = useState(null);
  const [description, setDescription] = useState("");
  const [detailedDescription, setDetailedDescription] = useState("");
  const getLocation = async () => {
    let { status } = await Location.requestForegroundPermissionsAsync();
    if (status !== "granted") {
      Alert.alert(
        "Permission denied",
        "Permission to access location was denied"
      );
      return;
    }
    let currentLocation = await Location.getCurrentPositionAsync({});
    setLocation({
      latitude: currentLocation.coords.latitude,
      longitude: currentLocation.coords.longitude,
    });
  };
  const pickImage = async () => {
    let result = await ImagePicker.launchCameraAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });
    if (!result.canceled) {
      const manipResult = await ImageManipulator.manipulateAsync(
        result.assets[0].uri,
        [],
        { compress: 0.5, format: ImageManipulator.SaveFormat.JPEG }
      );
      setImage(manipResult.uri);
    } else {
      Alert.alert(
        "No Image",
        "No image was selected or the operation was canceled."
      );
    }
  };
  const saveInterestPoint = async () => {
    if (!location) {
      Alert.alert("Missing Location", "Please set a location before saving.");
      return;
    }
    if (!image) {
      Alert.alert("Missing Image", "Please take a photo before saving.");
      return;
    }
    if (!description) {
      Alert.alert(
        "Missing Description",
        "Please enter a description before saving."
      );
      return;
    }
    try {
      const imageName = image.split("/").pop();
      const imagePath = `${FileSystem.documentDirectory}${imageName}`;
      await FileSystem.copyAsync({
        from: image,
        to: imagePath,
      });
      const interestPoint = {
        location,
        image: imagePath,
        description,
        detailedDescription, // Přidání detailního popisu
        timestamp: new Date().toISOString(),
      };
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      const points = storedPoints ? JSON.parse(storedPoints) : [];
      points.push(interestPoint);
      await AsyncStorage.setItem("interestPoints", JSON.stringify(points));
      Alert.alert("Saved", "Interest point saved successfully!");
      navigation.navigate("Home");
    } catch (error) {
      console.error("Error saving interest point:", error);
      Alert.alert(
        "Error",
        "An error occurred while saving the interest point."
      );
    }
  };
  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
    >
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <Button title="Set Location" onPress={getLocation} />
        {location && (
          <Text style={styles.text}>
            Location: {location.latitude}, {location.longitude}
          </Text>
        )}
        <Button title="Take a Photo" onPress={pickImage} />
        {image && <Image source={{ uri: image }} style={styles.image} />}
        <TextInput
          style={styles.input}
          placeholder="Enter description"
          value={description}
          onChangeText={setDescription}
        />
        <TextInput
          style={[styles.input, { height: 80 }]}
          placeholder="Enter detailed description"
          value={detailedDescription}
          onChangeText={setDetailedDescription}
          multiline
        />
        <Button title="Save Interest Point" onPress={saveInterestPoint} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
  },
  scrollContainer: {
    alignItems: "center",
    padding: 16,
  },
  text: {
    marginVertical: 10,
    fontSize: 16,
  },
  image: {
    width: 200,
    height: 200,
    marginVertical: 10,
  },
  input: {
    height: 40,
    borderColor: "gray",
    borderWidth: 1,
    width: "100%",
    paddingHorizontal: 10,
    marginVertical: 10,
  },
});


----- File: screens/InventoryScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, FlatList, Button, StyleSheet, Alert } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character"; // Ujisti se, že tento import směřuje na správný soubor

export default function InventoryScreen({ navigation }) {
  const [character, setCharacter] = useState(null);

  useEffect(() => {
    const loadCharacter = async () => {
      try {
        const storedCharacter = await AsyncStorage.getItem("activeCharacter");
        if (storedCharacter) {
          const parsedCharacter = JSON.parse(storedCharacter);
          const characterInstance = new Character(
            parsedCharacter.name,
            parsedCharacter.race,
            parsedCharacter.characterClass,
            parsedCharacter.naturalTalents,
            parsedCharacter.abilities,
            parsedCharacter.inventory
          );
          setCharacter(characterInstance);
        } else {
          console.error("Character not found in storage");
          Alert.alert("Error", "No active character found.");
          navigation.goBack();
        }
      } catch (error) {
        console.error("Error loading character:", error);
      }
    };

    loadCharacter();
  }, []);

  const handleUseItem = (item) => {
    Alert.alert("Use Item", `You used ${item.name}`);
    // Zde můžete implementovat logiku pro použití předmětu
  };

  const handleRemoveItem = async (item) => {
    Alert.alert(
      "Odstraň z inventáře",
      `Opravdu chcete odstranit ${item.name}?`,
      [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Odstraň z inventáře",
          onPress: async () => {
            if (character) {
              character.inventory = character.inventory.filter(
                (invItem) => invItem.name !== item.name
              );

              // Aktualizace postavy v AsyncStorage
              await AsyncStorage.setItem(
                "activeCharacter",
                JSON.stringify(character)
              );

              // Přidání předmětu zpět na mapu na aktuální lokaci
              const location = await Location.getCurrentPositionAsync({});
              const storedObjects = await AsyncStorage.getItem("placedObjects");
              const placedObjects = storedObjects
                ? JSON.parse(storedObjects)
                : [];
              const discardedObject = {
                ...item,
                location: {
                  latitude: location.coords.latitude,
                  longitude: location.coords.longitude,
                },
              };
              placedObjects.push(discardedObject);
              await AsyncStorage.setItem(
                "placedObjects",
                JSON.stringify(placedObjects)
              );
              Alert.alert("Předmět odstraněn a vrácen zpět na mapu.");
            }
          },
        },
      ]
    );
  };

  const handleEquipItem = (item) => {
    if (!character) {
      Alert.alert("Error", "Character is not initialized.");
      return;
    }

    Alert.alert("Equip Item", `Opravdu chcete vybavit ${item.name}?`, [
      { text: "Zrušit", style: "cancel" },
      {
        text: "Vybavit",
        onPress: () => {
          try {
            character.equipItem(item); // Volání metody z `Character.js`

            // Aktualizace postavy v AsyncStorage
            AsyncStorage.setItem("activeCharacter", JSON.stringify(character));
            Alert.alert(`${item.name} byl vybaven!`);
          } catch (error) {
            console.error("Error equipping item:", error);
            Alert.alert("Error", "Failed to equip item.");
          }
        },
      },
    ]);
  };

  const renderItem = ({ item }) => {
    let itemType = "";
    switch (item.type) {
      case "weapon":
        itemType = `W (Útok: +${item.properties.attackPoints})`;
        break;
      case "armor":
        itemType = `A (Obrana: +${item.properties.defensePoints})`;
        break;
      case "magicItem":
        itemType = `M (Efekt: +${item.properties.effectAmount})`;
        break;
      case "potion":
        itemType = `P (Efekt: +${item.properties.effectAmount} ${item.properties.effectType})`;
        break;
      case "scroll":
        itemType = `S (Kouzlo: ${item.properties.spellName})`;
        break;
      case "ring":
        itemType = `R (Efekt: +${item.properties.effectAmount})`;
        break;
      case "amulet":
        itemType = `N (Efekt: +${item.properties.effectAmount})`;
        break;
      default:
        itemType = "";
    }
    return (
      <View style={styles.itemContainer}>
        <Text style={styles.itemText}>
          {item.name} {itemType}
        </Text>
        <Text style={styles.itemDescription}>{item.description}</Text>
        <View style={styles.buttonContainer}>
          <Button title="Použít" onPress={() => handleUseItem(item)} />
          <Button title="Vybavit" onPress={() => handleEquipItem(item)} />
          <Button
            title="Odstraň z inventáře"
            onPress={() => handleRemoveItem(item)}
          />
        </View>
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={character?.inventory || []}
        keyExtractor={(item) => item.name}
        renderItem={renderItem}
        ListEmptyComponent={
          <Text style={styles.emptyText}>Váš inventář je prázdný.</Text>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  itemContainer: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: "#ccc",
  },
  itemText: {
    fontSize: 18,
    fontWeight: "bold",
  },
  itemDescription: {
    fontSize: 14,
    color: "#666",
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 10,
  },
  emptyText: {
    textAlign: "center",
    marginTop: 20,
    fontSize: 16,
    color: "#999",
  },
});


----- File: screens/KompasScreen.js -----
import React, { useState, useEffect } from "react";
import { View, StyleSheet, Image, Text, Button } from "react-native";
import { Magnetometer } from "expo-sensors";
import * as Location from "expo-location";
export default function KompasScreen({ route }) {
  const { point } = route.params;
  const [heading, setHeading] = useState(0);
  const [location, setLocation] = useState(null);
  const [distance, setDistance] = useState(null);
  useEffect(() => {
    const getLocation = async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        return;
      }
      let loc = await Location.getCurrentPositionAsync({});
      setLocation(loc.coords);
      setDistance(
        calculateDistance(
          loc.coords.latitude,
          loc.coords.longitude,
          point.latitude,
          point.longitude
        )
      );
    };
    const _subscribe = () => {
      Magnetometer.addListener((data) => {
        let { x, y } = data;
        let angle = Math.atan2(y, x) * (180 / Math.PI);
        if (angle < 0) {
          angle += 360;
        }
        setHeading(Math.round(angle));
      });
    };
    getLocation();
    _subscribe();
    return () => {
      Magnetometer.removeAllListeners();
    };
  }, [location]);
  const calculateBearing = (lat1, lon1, lat2, lon2) => {
    const toRadians = (deg) => deg * (Math.PI / 180);
    const toDegrees = (rad) => rad * (180 / Math.PI);
    const φ1 = toRadians(lat1);
    const φ2 = toRadians(lat2);
    const Δλ = toRadians(lon2 - lon1);
    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x =
      Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
    let brng = toDegrees(Math.atan2(y, x));
    return (brng + 360) % 360;
  };
  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3; // Poloměr Země v metrech
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // Vzdálenost v metrech
  };
  if (!location) {
    return (
      <View style={styles.container}>
        <Text>Loading...</Text>
      </View>
    );
  }
  const bearing = calculateBearing(
    location.latitude,
    location.longitude,
    point.latitude,
    point.longitude
  );
  const direction = (bearing - heading + 360) % 360;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>
        Aktuální GPS: {location.latitude}, {location.longitude}
      </Text>
      <Text style={styles.text}>
        Cíl GPS: {point.latitude}, {point.longitude}
      </Text>
      <Text style={styles.text}>Směr k cíli: {Math.round(direction)}°</Text>
      <Text style={styles.text}>
        Vzdálenost: {(distance / 1000).toFixed(2)} km
      </Text>
      <Image
        source={require("../assets/arrow.png")} // cesta k obrázku šipky
        style={[styles.arrow, { transform: [{ rotate: `${direction}deg` }] }]}
      />
      <Button
        title="Open Compass App"
        onPress={() => {
          // Zde by byla funkce pro otevření nativní kompasové aplikace
        }}
      />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#f5f5f5",
  },
  text: {
    fontSize: 18,
    marginBottom: 10,
  },
  arrow: {
    width: 200,
    height: 200,
  },
  distanceText: {
    marginTop: 20,
    fontSize: 24,
    color: "#333",
  },
});


----- File: screens/PhotoViewerScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Image,
  Button,
  Alert,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import styles from "../components/styles"; // Import stylů
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as FileSystem from "expo-file-system";
import { Ionicons } from "@expo/vector-icons"; // Import ikon
export default function PhotoViewerScreen({ navigation }) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [points, setPoints] = useState([]);
  const [imageExists, setImageExists] = useState(true);
  useEffect(() => {
    const loadPoints = async () => {
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      if (storedPoints) {
        const parsedPoints = JSON.parse(storedPoints);
        setPoints(parsedPoints);
        console.log("Loaded points:", parsedPoints);
      }
    };
    loadPoints();
  }, []);
  useEffect(() => {
    const checkImage = async () => {
      if (
        points.length > 0 &&
        points[currentIndex] &&
        points[currentIndex].image
      ) {
        const fileInfo = await FileSystem.getInfoAsync(
          points[currentIndex].image
        );
        console.log("Current image info:", fileInfo);
        if (!fileInfo.exists) {
          console.error("Image does not exist:", points[currentIndex].image);
          setImageExists(false);
        } else {
          console.log(
            "Image exists and will be displayed:",
            points[currentIndex].image
          );
          setImageExists(true);
        }
      }
    };
    checkImage();
  }, [currentIndex, points]);
  const handleNext = () => {
    setCurrentIndex((prevIndex) => (prevIndex + 1) % points.length);
  };
  const handlePrevious = () => {
    setCurrentIndex(
      (prevIndex) => (prevIndex - 1 + points.length) % points.length
    );
  };
  const handleDelete = async () => {
    Alert.alert(
      "Delete Point",
      "Are you sure you want to delete this point and its photo?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Yes",
          onPress: async () => {
            const updatedPoints = [...points];
            const [removedPoint] = updatedPoints.splice(currentIndex, 1);
            // Remove the image file from the file system if it exists
            if (removedPoint.image) {
              try {
                await FileSystem.deleteAsync(removedPoint.image);
                console.log("Image deleted:", removedPoint.image);
              } catch (error) {
                console.error("Error deleting image:", error);
              }
            }
            setPoints(updatedPoints);
            await AsyncStorage.setItem(
              "interestPoints",
              JSON.stringify(updatedPoints)
            );
            // If the last point was deleted, go back to the previous screen
            if (updatedPoints.length === 0) {
              navigation.goBack();
            } else if (currentIndex === updatedPoints.length) {
              setCurrentIndex(currentIndex - 1);
            }
          },
        },
      ],
      { cancelable: true }
    );
  };
  if (points.length === 0) {
    return (
      <View style={styles.container}>
        <Text style={styles.message}>No interest points found.</Text>
        <View style={styles.buttonContainer}>
          <Button title="Back" onPress={() => navigation.goBack()} />
        </View>
      </View>
    );
  }
  const currentPoint = points[currentIndex];
  return (
    <View style={styles.container}>
      {/* Přidání šipek nad fotkou */}
      <View style={localStyles.navigationContainer}>
        <TouchableOpacity
          onPress={handlePrevious}
          style={localStyles.navButton}
        >
          <Ionicons name="chevron-back-circle" size={30} color="black" />
          <Text style={localStyles.navText}>Previous</Text>
        </TouchableOpacity>
        <TouchableOpacity onPress={handleNext} style={localStyles.navButton}>
          <Text style={localStyles.navText}>Next</Text>
          <Ionicons name="chevron-forward-circle" size={30} color="black" />
        </TouchableOpacity>
      </View>
      {imageExists ? (
        <Image source={{ uri: currentPoint.image }} style={localStyles.image} />
      ) : (
        <Text>No image available</Text>
      )}
      <Text style={styles.text}>Description: {currentPoint.description}</Text>
      <Text style={styles.text}>
        Location: {currentPoint.location.latitude},{" "}
        {currentPoint.location.longitude}
      </Text>
      <View style={styles.buttonContainer}>
        <Button title="Delete Point" onPress={handleDelete} />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View on Map"
          onPress={() =>
            navigation.navigate("DynamicMap", {
              selectedPoint: currentPoint,
              zoom: 15,
            })
          }
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Edit Point"
          onPress={() =>
            navigation.navigate("Edit Point", { point: currentPoint })
          }
        />
      </View>
    </View>
  );
}
// Lokální stylování pro šipky a obrázek
const localStyles = StyleSheet.create({
  navigationContainer: {
    flexDirection: "row",
    justifyContent: "space-between", // Rozmístí šipky do krajů
    alignItems: "center",
    marginBottom: 10, // Přidání mezery mezi šipkami a fotkou
    width: "100%",
    paddingHorizontal: 20, // Odsazení od okrajů obrazovky
  },
  navButton: {
    flexDirection: "row",
    alignItems: "center",
  },
  navText: {
    fontSize: 16,
    marginHorizontal: 5,
  },
  image: {
    width: "100%",
    height: 300,
    resizeMode: "contain",
    marginBottom: 10,
  },
});


----- File: screens/PlaceObjectScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Modal,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Keyboard,
  TouchableWithoutFeedback,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Picker } from "@react-native-picker/picker";
import {
  standardWeapons,
  standardArmor,
  standardAccessories,
  standardPotions,
  standardScrolls,
  specialObjects,
} from "../data/standardItems";

export default function PlaceObjectScreen({ navigation }) {
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [type, setType] = useState("weapon");
  const [slot, setSlot] = useState(null);
  const [properties, setProperties] = useState({});
  const [modalVisible, setModalVisible] = useState(false);

  const handlePlaceObject = async () => {
    try {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        alert("Permission to access location was denied");
        return;
      }
      const location = await Location.getCurrentPositionAsync({});
      const newObject = {
        name,
        description,
        type,
        slot,
        properties,
        location: {
          latitude: location.coords.latitude,
          longitude: location.coords.longitude,
        },
      };
      const storedObjects = await AsyncStorage.getItem("placedObjects");
      const placedObjects = storedObjects ? JSON.parse(storedObjects) : [];
      placedObjects.push(newObject);
      await AsyncStorage.setItem(
        "placedObjects",
        JSON.stringify(placedObjects)
      );
      alert("Object placed successfully!");
      navigation.goBack();
    } catch (error) {
      console.error("Error placing object:", error);
      alert("There was an error placing the object.");
    }
  };

  const objectTypes = [
    { label: "Weapon", value: "weapon" },
    { label: "Armor", value: "armor" },
    { label: "Accessory", value: "accessory" },
    { label: "Potion", value: "potion" },
    { label: "Scroll", value: "scroll" },
    { label: "Special", value: "special" },
  ];

  const getItemsByType = (selectedType) => {
    switch (selectedType) {
      case "weapon":
        return standardWeapons;
      case "armor":
        return standardArmor;
      case "accessory":
        return standardAccessories;
      case "potion":
        return standardPotions;
      case "scroll":
        return standardScrolls;
      case "special":
        return specialObjects;
      default:
        return [];
    }
  };

  const handleTypeChange = (selectedType) => {
    setType(selectedType);
    setProperties({});
    const items = getItemsByType(selectedType);
    if (items.length > 0) {
      const defaultItem = items[0];
      setName(defaultItem.name);
      setProperties(defaultItem.properties);
      setSlot(defaultItem.slot);
    }
  };

  const renderPropertiesInput = () => {
    switch (type) {
      case "weapon":
        return (
          <>
            <Text style={styles.label}>Weapon Type:</Text>
            <Picker
              selectedValue={name}
              onValueChange={(value) => {
                const selectedWeapon = standardWeapons.find(
                  (weapon) => weapon.name === value
                );
                setName(selectedWeapon.name);
                setProperties(selectedWeapon.properties);
                setSlot(selectedWeapon.slot);
              }}
            >
              {standardWeapons.map((weapon) => (
                <Picker.Item
                  key={weapon.name}
                  label={weapon.name}
                  value={weapon.name}
                />
              ))}
            </Picker>
            <Text style={styles.label}>Weight: {properties.weight}</Text>
            <Text style={styles.label}>
              Attack Points: {properties.attackPoints}
            </Text>
            <Text style={styles.label}>
              Defense Points: {properties.defensePoints || 0}
            </Text>
          </>
        );
      case "armor":
        return (
          <>
            <Text style={styles.label}>Armor Type:</Text>
            <Picker
              selectedValue={name}
              onValueChange={(value) => {
                const selectedArmor = standardArmor.find(
                  (armor) => armor.name === value
                );
                setName(selectedArmor.name);
                setProperties(selectedArmor.properties);
                setSlot(selectedArmor.slot);
              }}
            >
              {standardArmor.map((armor) => (
                <Picker.Item
                  key={armor.name}
                  label={armor.name}
                  value={armor.name}
                />
              ))}
            </Picker>
            <Text style={styles.label}>Weight: {properties.weight}</Text>
            <Text style={styles.label}>
              Defense Points: {properties.defensePoints}
            </Text>
          </>
        );
      // Similar case for accessories, potions, scrolls, etc.
      default:
        return null;
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <Text style={styles.label}>Object Name:</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Enter object name"
        />
        <Text style={styles.label}>Object Description:</Text>
        <TextInput
          style={styles.input}
          value={description}
          onChangeText={setDescription}
          placeholder="Enter object description"
          multiline
        />
        <Text style={styles.label}>Object Type:</Text>
        <TouchableOpacity
          style={styles.picker}
          onPress={() => setModalVisible(true)}
        >
          <Text>{objectTypes.find((item) => item.value === type)?.label}</Text>
        </TouchableOpacity>
        <Modal
          animationType="slide"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => setModalVisible(!modalVisible)}
        >
          <View style={styles.modalView}>
            {objectTypes.map((item) => (
              <TouchableOpacity
                key={item.value}
                style={styles.modalItem}
                onPress={() => {
                  handleTypeChange(item.value);
                  setModalVisible(false);
                }}
              >
                <Text>{item.label}</Text>
              </TouchableOpacity>
            ))}
            <Button title="Cancel" onPress={() => setModalVisible(false)} />
          </View>
        </Modal>
        {renderPropertiesInput()}
        <Button title="Place Object" onPress={handlePlaceObject} />
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});


----- File: screens/ReturnPointScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  ActivityIndicator,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function ReturnPointScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [loading, setLoading] = useState(false);
  const [errorMsg, setErrorMsg] = useState(null);
  useEffect(() => {
    loadReturnPoint();
  }, []);
  const getLocation = async () => {
    try {
      setLoading(true);
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        console.log("Permission to access location was denied");
        setErrorMsg("Permission to access location was denied");
        setLoading(false);
        return;
      }
      let currentLocation = await Location.getCurrentPositionAsync({});
      const newLocation = {
        latitude: currentLocation.coords.latitude,
        longitude: currentLocation.coords.longitude,
      };
      setLocation(newLocation);
      await AsyncStorage.setItem("returnPoint", JSON.stringify(newLocation));
      setLoading(false);
    } catch (error) {
      console.error("Error getting location:", error);
      setErrorMsg("Error getting location");
      setLoading(false);
    }
  };
  const loadReturnPoint = async () => {
    try {
      const savedLocation = await AsyncStorage.getItem("returnPoint");
      if (savedLocation) {
        setLocation(JSON.parse(savedLocation));
      }
    } catch (error) {
      console.error("Error loading return point:", error);
      setErrorMsg("Error loading return point");
    }
  };
  if (loading || !location) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#0000ff" />
        <Text>{loading ? "Setting return point..." : "Loading map..."}</Text>
        {errorMsg ? <Text>{errorMsg}</Text> : null}
      </View>
    );
  }
  const leafletHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
      <style>
        #map {
          width: 100%;
          height: 100vh;
        }
      </style>
    </head>
    <body>
      <div id="map"></div>
      <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
      <script>
        var map = L.map('map').setView([${location.latitude}, ${location.longitude}], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors'
        }).addTo(map);
        var marker = L.marker([${location.latitude}, ${location.longitude}]).addTo(map);
        marker.bindPopup("<b>Return Point</b><br>This is your return point.").openPopup();
      </script>
    </body>
    </html>
  `;
  return (
    <View style={styles.container}>
      <Button title="Set Return Point" onPress={getLocation} />
      <View style={styles.mapContainer}>
        <WebView
          originWhitelist={["*"]}
          source={{ html: leafletHtml }}
          style={styles.map}
        />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  text: {
    marginVertical: 10,
    fontSize: 16,
  },
  mapContainer: {
    width: "100%",
    height: "80%",
    marginTop: 10,
  },
  map: {
    flex: 1,
  },
});


----- File: screens/SearchAreaScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  ScrollView,
  Alert,
  TouchableWithoutFeedback,
  Keyboard,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character"; // Ujisti se, že tento import směřuje na správný soubor

export default function SearchAreaScreen({ navigation }) {
  const [foundObjects, setFoundObjects] = useState([]);
  const [character, setCharacter] = useState(null); // Přidáme state pro charakter

  useEffect(() => {
    const searchArea = async () => {
      try {
        let { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== "granted") {
          alert("Permission to access location was denied");
          return;
        }
        const location = await Location.getCurrentPositionAsync({});
        const storedObjects = await AsyncStorage.getItem("placedObjects");
        const placedObjects = storedObjects ? JSON.parse(storedObjects) : [];
        const nearbyObjects = placedObjects.filter(
          (obj) =>
            getDistance(
              obj.location.latitude,
              obj.location.longitude,
              location.coords.latitude,
              location.coords.longitude
            ) <= 5
        );
        if (nearbyObjects.length > 0) {
          setFoundObjects(nearbyObjects);
        } else {
          setFoundObjects([]);
        }

        // Nalezení aktivní postavy
        const storedCharacters = await AsyncStorage.getItem("characters");
        if (storedCharacters) {
          const characters = JSON.parse(storedCharacters);
          const activeCharacter = characters.find((char) => char.isActive);
          if (activeCharacter) {
            setCharacter(
              new Character(
                activeCharacter.name,
                activeCharacter.race,
                activeCharacter.characterClass
              )
            ); // Vytvoření instance Character
            console.log("Active character loaded:", activeCharacter);
          } else {
            Alert.alert(
              "No active character",
              "Please select or create a character."
            );
            navigation.goBack();
          }
        } else {
          Alert.alert(
            "No characters found",
            "Please create a character first."
          );
          navigation.goBack();
        }
      } catch (error) {
        console.error("Error searching area or loading character:", error);
      }
    };
    searchArea();
  }, []);

  const getDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3; // Radius of the Earth in meters
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon1 - lon2) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  const handleSaveToInventory = async (object) => {
    try {
      if (!character) {
        console.log("Character not found in handleSaveToInventory");
        throw new Error(
          "No character found. Please select or create a character."
        );
      }

      const isBetterItem = character.compareItem(object);

      if (isBetterItem) {
        Alert.alert(
          "New item found!",
          `This ${object.name} seems better than my current equipment. Should I equip it?`,
          [
            { text: "No, keep current equipment", style: "cancel" },
            {
              text: "Yes, equip it",
              onPress: async () => {
                character.equipItem(object);
                await AsyncStorage.setItem(
                  "activeCharacter",
                  JSON.stringify(character)
                );

                // Remove the object from placedObjects in AsyncStorage
                const storedObjects = await AsyncStorage.getItem(
                  "placedObjects"
                );
                let placedObjects = storedObjects
                  ? JSON.parse(storedObjects)
                  : [];
                // Filter out the object that has been picked up
                placedObjects = placedObjects.filter(
                  (obj) =>
                    obj.name !== object.name ||
                    obj.location.latitude !== object.location.latitude ||
                    obj.location.longitude !== object.location.longitude
                );
                // Update placedObjects in AsyncStorage
                await AsyncStorage.setItem(
                  "placedObjects",
                  JSON.stringify(placedObjects)
                );
                // Update the state to remove the object from the UI
                setFoundObjects(placedObjects);
                Alert.alert(
                  `${object.name} equipped, saved to inventory, and removed from the map!`
                );
              },
            },
          ]
        );
      } else {
        // Standard inventory save logic
        const storedInventory = await AsyncStorage.getItem("inventory");
        const inventory = storedInventory ? JSON.parse(storedInventory) : [];
        inventory.push(object);
        await AsyncStorage.setItem("inventory", JSON.stringify(inventory));
        // Remove the object from placedObjects in AsyncStorage
        const storedObjects = await AsyncStorage.getItem("placedObjects");
        let placedObjects = storedObjects ? JSON.parse(storedObjects) : [];
        // Filter out the object that has been picked up
        placedObjects = placedObjects.filter(
          (obj) =>
            obj.name !== object.name ||
            obj.location.latitude !== obj.location.latitude ||
            obj.location.longitude !== obj.location.longitude
        );
        // Update placedObjects in AsyncStorage
        await AsyncStorage.setItem(
          "placedObjects",
          JSON.stringify(placedObjects)
        );
        // Update the state to remove the object from the UI
        setFoundObjects(placedObjects);
        Alert.alert(
          `${object.name} saved to inventory and removed from the map!`
        );
      }
    } catch (error) {
      console.error("Error saving to inventory:", error);
      Alert.alert("There was an error saving the object to your inventory.");
    }
  };

  const handleEnterDungeon = (dungeon) => {
    navigation.navigate("DungeonScreen", { dungeon });
  };

  const handleUnlockObject = async (lockObject) => {
    try {
      const storedInventory = await AsyncStorage.getItem("inventory");
      const inventory = storedInventory ? JSON.parse(storedInventory) : [];
      const hasKey = inventory.some(
        (item) => item.type === "key" && item.unlocks === lockObject.name
      );
      if (hasKey) {
        Alert.alert(`${lockObject.name} unlocked!`);
        // Implement your unlock logic here
      } else {
        Alert.alert(`You need a key to unlock ${lockObject.name}.`);
      }
    } catch (error) {
      console.error("Error unlocking object:", error);
      Alert.alert("There was an error unlocking the object.");
    }
  };

  const handleSaveToBook = async (object) => {
    try {
      const storedEntries = await AsyncStorage.getItem("bookEntries");
      const bookEntries = storedEntries ? JSON.parse(storedEntries) : [];
      bookEntries.push(object);
      await AsyncStorage.setItem("bookEntries", JSON.stringify(bookEntries));
      Alert.alert(`${object.name} saved to your book!`);
    } catch (error) {
      console.error("Error saving to book:", error);
      Alert.alert("There was an error saving the object to your book.");
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        {character && (
          <View style={styles.characterContainer}>
            <Text style={styles.characterName}>
              Active Character: {character.name}
            </Text>
            <Text>Class: {character.characterClass}</Text>
            <Text>Level: {character.level}</Text>
          </View>
        )}
        {foundObjects.length > 0 ? (
          <ScrollView>
            {foundObjects.map((object, index) => (
              <View key={index} style={styles.objectContainer}>
                <Text style={styles.label}>You found:</Text>
                <Text style={styles.objectName}>{object.name}</Text>
                <Text style={styles.objectDescription}>
                  {object.description}
                </Text>
                {object.type === "dungeon" ? (
                  <Button
                    title="Enter Dungeon"
                    onPress={() => handleEnterDungeon(object)}
                  />
                ) : object.type === "lock" ? (
                  <Button
                    title="Unlock"
                    onPress={() => handleUnlockObject(object)}
                  />
                ) : object.type === "sign" ? (
                  <Button
                    title="Save to Book"
                    onPress={() => handleSaveToBook(object)}
                  />
                ) : (
                  <Button
                    title="Save to Inventory"
                    onPress={() => handleSaveToInventory(object)}
                  />
                )}
              </View>
            ))}
          </ScrollView>
        ) : (
          <Text style={styles.label}>Nothing found in the area.</Text>
        )}
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    justifyContent: "center",
    alignItems: "center",
  },
  characterContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
    alignItems: "center",
  },
  characterName: {
    fontSize: 20,
    fontWeight: "bold",
  },
  objectContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  objectName: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 8,
  },
  objectDescription: {
    fontSize: 16,
    marginBottom: 16,
  },
});


----- File: screens/SettingsScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  Alert,
  TouchableOpacity,
  Linking,
  StyleSheet,
} from "react-native";
import { Picker } from "@react-native-picker/picker";
import styles from "../components/styles";
import { importData } from "../components/importData";
import { exportData } from "../components/exportData";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function SettingsScreen({ navigation }) {
  const [selectedMode, setSelectedMode] = useState("Herní režim");
  const [loading, setLoading] = useState(false);
  const handleModeChange = (mode) => {
    setSelectedMode(mode);
    Alert.alert("Režim změněn", `Aktuální režim je nyní: ${mode}`);
  };
  const deleteAllData = async () => {
    Alert.alert(
      "Smazat všechna data?",
      "Opravdu chcete smazat všechna data? Tato akce je nevratná.",
      [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Ano",
          onPress: async () => {
            try {
              await AsyncStorage.clear();
              Alert.alert("Úspěch", "Všechna data byla smazána.");
            } catch (error) {
              Alert.alert("Chyba", "Došlo k chybě při mazání dat.");
              console.error("Delete error:", error);
            }
          },
        },
      ],
      { cancelable: true }
    );
  };
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Settings</Text>
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Mode Settings</Text>
        <View style={styles.pickerContainer}>
          <Picker
            selectedValue={selectedMode}
            style={styles.picker}
            onValueChange={(itemValue) => handleModeChange(itemValue)}
          >
            <Picker.Item label="Herní režim" value="Herní režim" />
            <Picker.Item label="Výletní režim" value="Výletní režim" />
            <Picker.Item label="Admin režim" value="Admin režim" />
          </Picker>
        </View>
      </View>
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Data Management</Text>
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Export Data"
          onPress={() => exportData(setLoading)}
          disabled={loading}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Import Data"
          onPress={() => importData(setLoading)}
          disabled={loading}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="Delete All Data" onPress={deleteAllData} />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="About" onPress={() => navigation.navigate("About")} />
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={localStyles.aboutButton}
          onPress={() =>
            Linking.openURL("https://www.facebook.com/groups/461720089986492")
          }
        >
          <Text style={localStyles.aboutButtonText}>
            VentureOut Facebook Group
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}
// Přidání stylů pro tlačítko About
const localStyles = StyleSheet.create({
  aboutButton: {
    backgroundColor: "#007bff",
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 5,
    marginTop: 10,
  },
  aboutButtonText: {
    color: "white",
    fontWeight: "bold",
    textAlign: "center",
  },
});


===== Directory: data =====
----- File: data/CharacterAttributes.js -----
const CharacterAttributes = {
  genderModifiers: {
    Male: {
      strength: 1,
      speed: 0,
      agility: 0,
    },
    Female: {
      strength: -1,
      speed: 1,
      agility: 1,
    },
  },
};
export default CharacterAttributes;


----- File: data/CharacterClasses.js -----
const CharacterClasses = {
  Warrior: {
    name: "Warrior",
    description: "A strong and brave fighter, skilled in melee combat.",
    strength: 3,
    defense: 2,
    attack: 2,
    speed: 0,
    mana: -10,
    health: 20,
  },
  Mage: {
    name: "Mage",
    description: "A master of the arcane, powerful in magic.",
    strength: 0,
    defense: 0,
    attack: 1,
    speed: 0,
    mana: 30,
    health: -10,
  },
  Rogue: {
    name: "Rogue",
    description: "A stealthy and agile character, skilled in evasion.",
    strength: 1,
    defense: 0,
    attack: 2,
    speed: 3,
    mana: 0,
    health: 0,
  },
};
export default CharacterClasses;


----- File: data/Races.js -----
class Race {
  constructor(name, traits, attributeModifiers) {
    this.name = name;
    this.traits = traits; // Pole vlastností, např. Darkvision
    this.attributeModifiers = attributeModifiers; // Objekt obsahující modifikátory atributů
  }
}

// Definice ras v souladu s tvými požadavky
export const Races = {
  Human: new Race("Human", ["Versatile"], {
    strength: 9, // Base Attack = 9
    attack: 2,
    defense: 4, // Base Defense = 4
    speed: 8, // Base Speed = 8
    luck: 2, // Mírný bonus k štěstí
    courage: 5, // Mírný bonus ke kuráži
    magic: 1, // Základní magie
  }),
  Orc: new Race("Orc", ["Savage Attacks", "Menacing"], {
    strength: 14, // Velká síla
    defense: 10, // Vysoká obrana
    attack: 5,
    speed: 6, // Pomalejší pohyb
    luck: 1,
    courage: 8, // Velká kuráž
    magic: 0, // Žádná magie
  }),
  Elf: new Race("Elf", ["Darkvision", "Keen Senses"], {
    strength: 8, // Nižší síla než u lidí
    defense: 5, // Vyšší obrana než u lidí
    attack: 2,
    speed: 10, // Rychlejší než lidé a trpaslíci
    luck: 3, // Vyšší štěstí
    courage: 6, // Odvážní, ale méně než orci
    magic: 10, // Silná magie
  }),
  Dwarf: new Race("Dwarf", ["Darkvision", "Resilience"], {
    strength: 12, // Silnější než lidé, ale slabší než orci
    defense: 12, // Vysoká obrana
    attack: 3,
    speed: 7, // Pomalejší než elfové
    luck: 2, // Základní štěstí
    courage: 7, // Odvážní a houževnatí
    magic: 2, // Základní znalosti magie
  }),
};

export default Race;


----- File: data/standardItems.js -----
export const standardWeapons = [
  {
    name: "Short Sword",
    properties: {
      attackPoints: 3,
      defensePoints: 1,
      weight: 2,
    },
    slot: "hand",
  },
  {
    name: "Long Sword",
    properties: {
      attackPoints: 5,
      defensePoints: 2,
      weight: 4,
    },
    slot: "hand",
  },
  {
    name: "Rapier",
    properties: {
      attackPoints: 4,
      defensePoints: 1,
      weight: 3,
    },
    slot: "hand",
  },
  {
    name: "Battle Axe",
    properties: {
      attackPoints: 6,
      defensePoints: 2,
      weight: 5,
    },
    slot: "hand",
  },
  {
    name: "War Hammer",
    properties: {
      attackPoints: 7,
      defensePoints: 3,
      weight: 6,
    },
    slot: "hand",
  },
];

export const standardArmor = [
  {
    name: "Leather Armor",
    properties: {
      defensePoints: 2,
      weight: 5,
    },
    slot: "body",
  },
  {
    name: "Chainmail Armor",
    properties: {
      defensePoints: 4,
      weight: 10,
    },
    slot: "body",
  },
  {
    name: "Plate Armor",
    properties: {
      defensePoints: 6,
      weight: 15,
    },
    slot: "body",
  },
  {
    name: "Shield",
    properties: {
      defensePoints: 2,
      weight: 4,
    },
    slot: "hand",
  },
];

export const standardAccessories = [
  {
    name: "Ring of Strength",
    properties: {
      strength: 2,
      weight: 0.1,
    },
    slot: "finger",
  },
  {
    name: "Amulet of Protection",
    properties: {
      defensePoints: 3,
      weight: 0.2,
    },
    slot: "neck",
  },
  {
    name: "Ring of Speed",
    properties: {
      speed: 2,
      weight: 0.1,
    },
    slot: "finger",
  },
];

export const standardPotions = [
  {
    name: "Potion of Healing",
    properties: {
      healingPoints: 20,
      weight: 0.5,
    },
    slot: "consumable",
  },
  {
    name: "Potion of Strength",
    properties: {
      strength: 3,
      weight: 0.5,
    },
    slot: "consumable",
  },
];

export const standardScrolls = [
  {
    name: "Scroll of Fireball",
    properties: {
      magicDamage: 15,
      weight: 0.3,
    },
    slot: "consumable",
  },
  {
    name: "Scroll of Healing",
    properties: {
      healingPoints: 20,
      weight: 0.3,
    },
    slot: "consumable",
  },
];

export const specialObjects = [
  {
    name: "Dungeon Entrance",
    properties: {
      type: "dungeon",
      weight: 0,
    },
    slot: "special",
  },
  {
    name: "Engraving",
    properties: {
      type: "inscription",
      weight: 0,
    },
    slot: "special",
  },
];


===== Directory: utils =====
----- File: utils/generateEnemy.js -----


