===== Directory: screens =====
----- File: screens/AboutScreen.js -----
import React from "react";
import { View, Text, ScrollView, StyleSheet } from "react-native";
export default function AboutScreen() {
  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>About Return</Text>
      <Text style={styles.paragraph}>
        Welcome to Return! Our system for character creation and attribute
        management is inspired by Dungeons & Dragons (D&D), but with some key
        differences and simplifications.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Attributes:</Text>
        {"\n"}D&D uses six main attributes (Strength, Dexterity, Constitution,
        Intelligence, Wisdom, Charisma) that influence various aspects of a
        character, such as combat abilities, skills, magic, and resilience.
        {"\n"}Our system uses similar attributes but they are reduced in number
        and have simpler applications. For example, our attributes include
        Strength, Defense, Attack, Speed, Luck, Courage, which is a mix of
        physical and mental characteristics.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Races and Classes:</Text>
        {"\n"}In D&D, a character's race and class have complex interactions
        where the race provides specific bonuses to attributes, and the class
        determines skills, abilities, spells, and hit points (HP). Each
        race-class combination can lead to very different characters with
        various strengths and weaknesses.
        {"\n"}In our system, race and class also provide bonuses to attributes,
        but our classes do not directly affect base attributes (e.g., magic,
        speed). Instead, the class defines the basic role and can influence
        skills and special abilities of the character in a simpler and less
        modular way than in D&D.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Generating Attributes:</Text>
        {"\n"}In D&D, attributes are usually generated by rolling dice (e.g.,
        4d6 and keeping the highest three values), adding an element of
        randomness and imbalance between characters.
        {"\n"}Our system has predefined attribute values based on race and class
        choices. This ensures greater balance and predictability but also limits
        diversity.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Leveling Up:</Text>
        {"\n"}In D&D, as a character levels up, they can increase their
        attributes and gain new abilities, spells, and skills. This process is
        highly detailed, allowing players to customize their characters to suit
        their play style.
        {"\n"}In our system, leveling up would also allow attributes to be
        increased and new abilities to be gained, but likely with less emphasis
        on skills and more on core attributes and simple abilities.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Complexity and Flexibility:</Text>
        {"\n"}D&D is very flexible and complex, allowing players to create and
        customize their characters in various styles and stories. This
        complexity, however, can be challenging for new players.
        {"\n"}Our system is simplified to be more accessible and easier to
        implement. It offers fewer customization options but is also less
        complicated and easier to understand and manage.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Equipment and Spells:</Text>
        {"\n"}In D&D, different types of equipment and spells have very specific
        and varying effects, often with complex rules on how they interact with
        each other.
        {"\n"}Our system likely simplifies equipment and spells, making their
        effects easier to manage and understand.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Conclusion:</Text>
        {"\n"}Our system is simplified and tailored for quick implementation and
        easy use, while D&D is complex and offers much greater depth for
        advanced players who want to customize every aspect of their character.
        The simplifications we have made ensure that the game remains accessible
        and fun without being burdened by too much complexity.
      </Text>
    </ScrollView>
  );
}
const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 20,
  },
  paragraph: {
    fontSize: 16,
    marginBottom: 15,
  },
  subtitle: {
    fontWeight: "bold",
    fontSize: 18,
  },
});


----- File: screens/ActionsMenuScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, Button } from "react-native";
import styles from "../components/styles";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function ActionsMenuScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [characterExists, setCharacterExists] = useState(false);
  useEffect(() => {
    const checkCharacter = async () => {
      try {
        const storedCharacters = await AsyncStorage.getItem("characters");
        console.log("Stored characters:", storedCharacters);
        if (storedCharacters) {
          const characters = JSON.parse(storedCharacters);
          const activeCharacter = characters.find((char) => char.isActive);
          setCharacterExists(!!activeCharacter);
          console.log("Active character exists:", !!activeCharacter);
        } else {
          setCharacterExists(false);
        }
      } catch (error) {
        console.error("Error checking character:", error);
      }
    };
    const updateLocation = async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        console.log("Permission to access location was denied");
        return;
      }
      const loc = await Location.getCurrentPositionAsync({});
      setLocation({
        latitude: loc.coords.latitude,
        longitude: loc.coords.longitude,
      });
    };
    checkCharacter();
    const intervalId = setInterval(updateLocation, 2000);
    return () => clearInterval(intervalId);
  }, []);
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Actions</Text>
      {location ? (
        <Text style={styles.coords}>
          Latitude: {location.latitude.toFixed(6)}
          {"\n"}
          Longitude: {location.longitude.toFixed(6)}
        </Text>
      ) : (
        <Text style={styles.coords}>Loading GPS coordinates...</Text>
      )}
      <View style={styles.buttonContainer}>
        <Button
          title="Place Object"
          onPress={() => navigation.navigate("Place Object")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Search Area"
          onPress={() => navigation.navigate("Search Area")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Inventory"
          onPress={() => navigation.navigate("Inventory")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Tasks"
          onPress={() => navigation.navigate("Tasks")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={characterExists ? "Select Character" : "Create Character"}
          onPress={() => navigation.navigate("CharacterSelection")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
    </View>
  );
}


----- File: screens/BookScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, ScrollView, StyleSheet } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function BookScreen({ navigation }) {
  const [entries, setEntries] = useState([]);
  useEffect(() => {
    const loadEntries = async () => {
      try {
        const storedEntries = await AsyncStorage.getItem("bookEntries");
        const bookEntries = storedEntries ? JSON.parse(storedEntries) : [];
        setEntries(bookEntries);
      } catch (error) {
        console.error("Error loading book entries:", error);
      }
    };
    loadEntries();
  }, []);
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Your Book</Text>
      <ScrollView>
        {entries.length > 0 ? (
          entries.map((entry, index) => (
            <View key={index} style={styles.entryContainer}>
              <Text style={styles.entryTitle}>{entry.name}</Text>
              <Text style={styles.entryText}>{entry.description}</Text>
            </View>
          ))
        ) : (
          <Text style={styles.noEntries}>Your book is empty.</Text>
        )}
      </ScrollView>
      <Button title="Back" onPress={() => navigation.goBack()} />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 16,
    textAlign: "center",
  },
  entryContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
  },
  entryTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 8,
  },
  entryText: {
    fontSize: 16,
  },
  noEntries: {
    fontSize: 18,
    textAlign: "center",
    marginTop: 20,
  },
});


----- File: screens/CharacterCreationScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  TouchableOpacity,
  StyleSheet,
  Modal,
  TextInput,
  TouchableWithoutFeedback,
  Keyboard,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Races } from "../data/Races"; // Opravený import ras
import CharacterClasses from "../data/CharacterClasses"; // Import tříd
import CharacterAttributes from "../data/CharacterAttributes"; // Import atributů
import Character from "../models/Character"; // Import modelu postavy

const CharacterCreationScreen = ({ navigation }) => {
  const [name, setName] = useState("");
  const [selectedRace, setSelectedRace] = useState(null);
  const [selectedGender, setSelectedGender] = useState(null);
  const [selectedClass, setSelectedClass] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [isSelectingRace, setIsSelectingRace] = useState(true);
  const [isSelectingGender, setIsSelectingGender] = useState(false);
  const [isSelectingClass, setIsSelectingClass] = useState(false);
  const [characterAttributes, setCharacterAttributes] = useState({
    strength: 0,
    defense: 0,
    attack: 0,
    speed: 0,
    luck: 0,
    courage: 0,
    mana: 50,
    health: 100,
    level: 1, // Nastavujeme počáteční úroveň postavy
  });

  const handleSelectRace = (race) => {
    if (!race) {
      console.error("Invalid race selected.");
      return;
    }
    setSelectedRace(race);
    setCharacterAttributes({
      strength: race.attributeModifiers.strength || 0,
      defense: race.attributeModifiers.defense || 0,
      attack: race.attributeModifiers.attack || 0,
      speed: race.attributeModifiers.speed || 0,
      luck: race.attributeModifiers.luck || 0,
      courage: race.attributeModifiers.courage || 0,
      magic: race.attributeModifiers.magic || 0,
      mana: 50, // Resetovat mana na základní hodnotu
      health: 100, // Resetovat zdraví na základní hodnotu
      level: 1,
    });
    setIsSelectingRace(false);
    setIsSelectingGender(true);
    setModalVisible(false);
  };

  const handleSelectGender = (gender) => {
    setSelectedGender(gender);
    const genderModifier = CharacterAttributes.genderModifiers[gender] || {};

    // Resetuj hodnoty atributů na základní hodnoty podle vybrané rasy
    const baseAttributes = { ...selectedRace.attributeModifiers };

    // Přičti modifikátory pohlaví
    setCharacterAttributes((prevAttributes) => ({
      strength: baseAttributes.strength + (genderModifier.strength || 0),
      defense: baseAttributes.defense + (genderModifier.defense || 0),
      attack: baseAttributes.attack + (genderModifier.attack || 0),
      speed: baseAttributes.speed + (genderModifier.speed || 0),
      luck: baseAttributes.luck + (genderModifier.luck || 0),
      courage: baseAttributes.courage + (genderModifier.courage || 0),
      magic: baseAttributes.magic + (genderModifier.magic || 0),
      mana: prevAttributes.mana, // Udržet aktuální hodnoty many
      health: prevAttributes.health, // Udržet aktuální hodnoty zdraví
      level: prevAttributes.level,
    }));

    setIsSelectingGender(false);
    setIsSelectingClass(true);
    setModalVisible(false);
  };

  const handleSelectClass = (characterClass) => {
    setSelectedClass(characterClass);
    const classAttributes = CharacterClasses[characterClass];

    // Resetuj hodnoty atributů na základní hodnoty podle vybrané rasy a pohlaví
    const baseAttributes = {
      strength: characterAttributes.strength - (classAttributes.strength || 0),
      defense: characterAttributes.defense - (classAttributes.defense || 0),
      attack: characterAttributes.attack - (classAttributes.attack || 0),
      speed: characterAttributes.speed - (classAttributes.speed || 0),
      luck: characterAttributes.luck - (classAttributes.luck || 0),
      courage: characterAttributes.courage - (classAttributes.courage || 0),
      magic: characterAttributes.magic - (classAttributes.magic || 0),
      mana: characterAttributes.mana,
      health: characterAttributes.health,
      level: characterAttributes.level,
    };

    // Přičti modifikátory povolání
    setCharacterAttributes({
      ...baseAttributes,
      strength: baseAttributes.strength + (classAttributes.strength || 0),
      defense: baseAttributes.defense + (classAttributes.defense || 0),
      attack: baseAttributes.attack + (classAttributes.attack || 0),
      speed: baseAttributes.speed + (classAttributes.speed || 0),
      luck: baseAttributes.luck + (classAttributes.luck || 0),
      courage: baseAttributes.courage + (classAttributes.courage || 0),
      magic: baseAttributes.magic + (classAttributes.magic || 0),
      mana: baseAttributes.mana,
      health: baseAttributes.health,
      level: baseAttributes.level,
    });

    setIsSelectingClass(false);
    setModalVisible(false);
  };

  const handleSaveCharacter = async () => {
    if (!selectedRace || !selectedGender || !selectedClass) {
      alert("Please select a race, gender, and class.");
      return;
    }

    const newCharacter = new Character(
      name,
      selectedRace.name, // Přenese jméno rasy
      selectedClass,
      selectedGender,
      [], // naturalTalents
      [], // abilities
      [] // inventory
    );

    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      const characters = storedCharacters ? JSON.parse(storedCharacters) : [];
      characters.push(newCharacter);
      await AsyncStorage.setItem("characters", JSON.stringify(characters));
      navigation.navigate("CharacterSelection");
    } catch (error) {
      console.error("Failed to save character", error);
      alert("There was an error saving the character.");
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <Text style={styles.label}>Character Name:</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Enter character name"
        />
        <View style={styles.buttonSpacing}>
          <Button
            title="Select Race"
            onPress={() => {
              setIsSelectingRace(true);
              setModalVisible(true);
            }}
          />
        </View>
        {selectedRace && (
          <>
            <View style={styles.detailsContainer}>
              <Text>Selected Race: {selectedRace.name}</Text>
              <Text>Description: {selectedRace.description}</Text>
              <Text>Strength: {characterAttributes.strength}</Text>
              <Text>Defense: {characterAttributes.defense}</Text>
              <Text>Attack: {characterAttributes.attack}</Text>
              <Text>Speed: {characterAttributes.speed}</Text>
              <Text>Luck: {characterAttributes.luck}</Text>
              <Text>Courage: {characterAttributes.courage}</Text>
              <Text>Health: {characterAttributes.health}</Text>
              <Text>Mana: {characterAttributes.mana}</Text>
            </View>
            <View style={styles.buttonSpacing}>
              <Button
                title="Select Gender"
                onPress={() => {
                  setIsSelectingGender(true);
                  setModalVisible(true);
                }}
              />
            </View>
          </>
        )}
        {selectedGender && (
          <>
            <View style={styles.detailsContainer}>
              <Text>Selected Gender: {selectedGender}</Text>
            </View>
            <View style={styles.buttonSpacing}>
              <Button
                title="Select Class"
                onPress={() => {
                  setIsSelectingClass(true);
                  setModalVisible(true);
                }}
              />
            </View>
          </>
        )}
        {selectedClass && (
          <View style={styles.detailsContainer}>
            <Text>Selected Class: {selectedClass}</Text>
          </View>
        )}
        <View style={styles.buttonSpacing}>
          <Button title="Save Character" onPress={handleSaveCharacter} />
        </View>
        <Modal
          animationType="slide"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => setModalVisible(false)}
        >
          <View style={styles.modalView}>
            {isSelectingRace
              ? Object.values(Races).map((race) => (
                  <TouchableOpacity
                    key={race.name}
                    style={styles.modalItem}
                    onPress={() => handleSelectRace(race)}
                  >
                    <Text>{race.name}</Text>
                  </TouchableOpacity>
                ))
              : isSelectingGender
              ? ["Male", "Female"].map((gender) => (
                  <TouchableOpacity
                    key={gender}
                    style={styles.modalItem}
                    onPress={() => handleSelectGender(gender)}
                  >
                    <Text>{gender}</Text>
                  </TouchableOpacity>
                ))
              : Object.keys(CharacterClasses).map((characterClass) => (
                  <TouchableOpacity
                    key={characterClass}
                    style={styles.modalItem}
                    onPress={() => handleSelectClass(characterClass)}
                  >
                    <Text>{characterClass}</Text>
                  </TouchableOpacity>
                ))}
            <Button title="Cancel" onPress={() => setModalVisible(false)} />
          </View>
        </Modal>
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  detailsContainer: {
    marginTop: 16,
  },
  buttonSpacing: {
    marginVertical: 10,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});

export default CharacterCreationScreen;


----- File: screens/CharacterDetailScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  Alert,
  ScrollView,
} from "react-native";

export default function CharacterDetailScreen({ route }) {
  const { character } = route.params;

  // Logování celého objektu character
  console.log(JSON.stringify(character, null, 2));

  const [inventory, setInventory] = useState(character.inventory || []);

  const handleUnequipItem = (slot) => {
    const updatedEquipment = { ...character.equipment };
    const removedItem = updatedEquipment[slot];
    updatedEquipment[slot] = null;
    character.equipment = updatedEquipment;
    setInventory([...inventory, removedItem]);
    Alert.alert("Item removed", `The item from ${slot} was unequipped.`);
  };

  const handleEquipItem = (item) => {
    const updatedInventory = inventory.filter(
      (invItem) => invItem.id !== item.id
    );
    const updatedEquipment = { ...character.equipment };

    if (updatedEquipment[item.slot]) {
      setInventory([...updatedInventory, updatedEquipment[item.slot]]);
    }

    updatedEquipment[item.slot] = item;
    character.equipment = updatedEquipment;
    setInventory(updatedInventory);
    Alert.alert("Item equipped", `${item.name} was equipped to ${item.slot}.`);
  };
  const renderEquippedItem = (slot, label) => {
    const item = character.equipment[slot] || null;
    console.log(
      "Rendering item for slot:",
      slot,
      "Label:",
      label,
      "Item:",
      item
    );

    // Pokud item není, zobrazí se "None"
    if (!item) {
      return (
        <View style={styles.itemSlot}>
          <Text style={styles.itemSlotText}>{label}: None</Text>
        </View>
      );
    }

    // Pokud je item přítomen, ale nemá `name`, zobrazí se "Unnamed Item"
    return (
      <View style={styles.itemSlot}>
        <Text style={styles.itemSlotText}>
          {label}: {item.name || "Unnamed Item"}
        </Text>
        <Button title="Remove" onPress={() => handleUnequipItem(slot)} />
      </View>
    );
  };

  return (
    <ScrollView contentContainerStyle={styles.scrollContainer}>
      <View style={styles.container}>
        <Text style={styles.title}>{character.name}</Text>
        <Text>Race: {character.race}</Text>
        <Text>Class: {character.characterClass}</Text>
        <Text>Level: {character.level}</Text>
        <Text>Health: {character.health}</Text>
        <Text>Mana: {character.mana}</Text>
        <Text>Attack: {character.stats.attack}</Text>
        <Text>Defense: {character.stats.defense}</Text>
        <Text style={styles.sectionTitle}>Equipped Items:</Text>
        {character.equipment && renderEquippedItem("helmet", "Head")}
        {character.equipment && renderEquippedItem("necklace", "Neck")}
        {character.equipment && renderEquippedItem("chest", "Body")}
        {character.equipment && renderEquippedItem("gloves", "Hands")}
        {character.equipment && renderEquippedItem("legs", "Legs")}
        {character.equipment && renderEquippedItem("boots", "Feet")}
        {character.equipment && renderEquippedItem("weapon", "Weapon")}
        {character.equipment && renderEquippedItem("shield", "Shield")}
        <Text style={styles.sectionTitle}>Inventory:</Text>
        {inventory.length > 0 ? (
          inventory.map((item, index) => (
            <View
              key={item?.id || index.toString()}
              style={styles.inventoryItem}
            >
              <Text>{item?.name || "Unnamed Item"}</Text>
              <Button title="Equip" onPress={() => handleEquipItem(item)} />
            </View>
          ))
        ) : (
          <Text>No items in inventory.</Text>
        )}
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  scrollContainer: {
    paddingBottom: 20,
  },
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
  },
  sectionTitle: {
    fontSize: 20,
    marginTop: 20,
    marginBottom: 10,
    fontWeight: "bold",
  },
  itemSlot: {
    marginBottom: 20,
  },
  itemSlotText: {
    fontSize: 18,
    marginBottom: 10,
  },
  inventoryItem: {
    marginBottom: 10,
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 10,
    borderRadius: 5,
  },
});


----- File: screens/CharacterEquipmentScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Alert,
} from "react-native";
export default function CharacterEquipmentScreen({ route }) {
  const { character } = route.params;
  const [inventory, setInventory] = useState(
    initializeInventory(character.inventory)
  );
  const [selectedSlot, setSelectedSlot] = useState(null);
  function initializeInventory(inventory = {}) {
    return {
      head: inventory.head || null,
      neck: inventory.neck || null,
      body: inventory.body || null,
      hands: inventory.hands || [null, null],
      legs: inventory.legs || null,
      feet: inventory.feet || null,
      fingers: inventory.fingers || Array(10).fill(null),
      items: inventory.items || [],
    };
  }
  const handleEquipItem = (item) => {
    const updatedInventory = { ...inventory };
    if (selectedSlot.index !== null) {
      updatedInventory[selectedSlot.slot][selectedSlot.index] = item;
    } else {
      updatedInventory[selectedSlot.slot] = item;
    }
    setInventory(updatedInventory);
    setSelectedSlot(null);
    Alert.alert(
      "Item equipped",
      `${item.name} was equipped to ${selectedSlot.label}.`
    );
  };
  const renderSlot = (label, slot, index = null) => {
    const item = index !== null ? inventory[slot][index] : inventory[slot];
    return (
      <TouchableOpacity
        style={styles.slot}
        onPress={() => setSelectedSlot({ slot, index, label })}
      >
        <Text style={styles.slotLabel}>{label}</Text>
        <Text>{item ? item.name : "None"}</Text>
      </TouchableOpacity>
    );
  };
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{character.name}</Text>
      <Text>Level: {character.level}</Text>
      {/* Vizuální zobrazení těla */}
      <View style={styles.bodyContainer}>
        <View style={styles.upperBody}>
          {renderSlot("Head", "head")}
          {renderSlot("Neck", "neck")}
          {renderSlot("Body", "body")}
        </View>
        <View style={styles.hands}>
          {renderSlot("Left Hand", "hands", 0)}
          {renderSlot("Right Hand", "hands", 1)}
        </View>
        <View style={styles.lowerBody}>
          {renderSlot("Legs", "legs")}
          {renderSlot("Feet", "feet")}
        </View>
      </View>
      {/* Inventář pro vybavení */}
      {selectedSlot && (
        <View style={styles.inventoryContainer}>
          <Text>Equip item to {selectedSlot.label}:</Text>
          <FlatList
            data={inventory.items}
            keyExtractor={(item) => item.id.toString()}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.inventoryItem}
                onPress={() => handleEquipItem(item)}
              >
                <Text>{item.name}</Text>
              </TouchableOpacity>
            )}
          />
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#f5f5f5",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 16,
  },
  bodyContainer: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  upperBody: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "80%",
  },
  hands: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    marginTop: 20,
  },
  lowerBody: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "80%",
    marginTop: 20,
  },
  slot: {
    alignItems: "center",
    justifyContent: "center",
    padding: 10,
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 5,
    backgroundColor: "#fff",
    marginVertical: 5,
  },
  slotLabel: {
    fontWeight: "bold",
  },
  inventoryContainer: {
    padding: 16,
    backgroundColor: "#fff",
    borderTopWidth: 1,
    borderColor: "#ccc",
  },
  inventoryItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderColor: "#ccc",
  },
});


----- File: screens/CharacterSelectionScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
const CharacterSelectionScreen = ({ navigation }) => {
  const [characters, setCharacters] = useState([]);
  const [activeCharacter, setActiveCharacter] = useState(null);
  useEffect(() => {
    const unsubscribe = navigation.addListener("focus", () => {
      loadCharacters();
    });
    return unsubscribe;
  }, [navigation]);
  const loadCharacters = async () => {
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      if (storedCharacters) {
        const parsedCharacters = JSON.parse(storedCharacters);
        setCharacters(parsedCharacters);
        const activeChar = parsedCharacters.find((char) => char.isActive);
        setActiveCharacter(activeChar);
      }
    } catch (error) {
      console.error("Failed to load characters", error);
    }
  };
  const selectCharacter = async (character) => {
    // Označení vybrané postavy jako aktivní
    const updatedCharacters = characters.map((char) => ({
      ...char,
      isActive: char.name === character.name,
    }));
    setCharacters(updatedCharacters);
    await AsyncStorage.setItem("characters", JSON.stringify(updatedCharacters));
    setActiveCharacter(character);
    console.log("Selected character:", character);
    navigation.navigate("CharacterDetail", { character }); // Předání vybrané postavy do CharacterDetailScreen
  };
  const createCharacter = () => {
    // Přesměrování na obrazovku pro vytvoření postavy
    navigation.navigate("CharacterCreation");
  };
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Select Your Character</Text>
      {characters.length > 0 ? (
        <FlatList
          data={characters}
          keyExtractor={(item, index) => index.toString()}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={[
                styles.characterItem,
                item.isActive && styles.activeCharacterItem,
              ]}
              onPress={() => selectCharacter(item)}
            >
              <Text>
                {item.name} - {item.characterClass}{" "}
                {item.isActive ? "(Active)" : ""}
              </Text>
            </TouchableOpacity>
          )}
        />
      ) : (
        <View style={styles.noCharacterContainer}>
          <Text style={styles.noCharacterText}>No characters found.</Text>
          <Button title="Create Character" onPress={createCharacter} />
        </View>
      )}
      <Button title="Back" onPress={() => navigation.goBack()} />
    </View>
  );
};
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 20,
    textAlign: "center",
  },
  characterItem: {
    padding: 10,
    marginVertical: 8,
    backgroundColor: "#f9f9f9",
    borderColor: "#ddd",
    borderWidth: 1,
    borderRadius: 5,
  },
  activeCharacterItem: {
    backgroundColor: "#d0f0c0", // Zelenější barva pro označení aktivní postavy
  },
  noCharacterContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  noCharacterText: {
    fontSize: 18,
    marginBottom: 20,
  },
});
export default CharacterSelectionScreen;


----- File: screens/CharacterSettingsScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Alert,
  Modal,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function CharacterSettingsScreen({ navigation }) {
  const [name, setName] = useState("");
  const [characterClass, setCharacterClass] = useState("Warrior");
  const [characterList, setCharacterList] = useState([]);
  const [modalVisible, setModalVisible] = useState(false);
  useEffect(() => {
    loadCharacters();
  }, []);
  const loadCharacters = async () => {
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      if (storedCharacters) {
        setCharacterList(JSON.parse(storedCharacters));
      }
    } catch (error) {
      console.error("Failed to load characters", error);
    }
  };
  const saveCharacter = async () => {
    try {
      const newCharacter = { name, characterClass };
      const updatedCharacterList = [...characterList, newCharacter];
      setCharacterList(updatedCharacterList);
      await AsyncStorage.setItem(
        "characters",
        JSON.stringify(updatedCharacterList)
      );
      Alert.alert("Success", "Character saved!");
    } catch (error) {
      console.error("Failed to save character", error);
      Alert.alert("Error", "Failed to save character");
    }
  };
  const deleteCharacter = async (index) => {
    try {
      const updatedCharacterList = characterList.filter((_, i) => i !== index);
      setCharacterList(updatedCharacterList);
      await AsyncStorage.setItem(
        "characters",
        JSON.stringify(updatedCharacterList)
      );
      Alert.alert("Success", "Character deleted!");
    } catch (error) {
      console.error("Failed to delete character", error);
      Alert.alert("Error", "Failed to delete character");
    }
  };
  const characterClasses = ["Warrior", "Mage", "Rogue"]; // Přidat další třídy podle potřeby
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Character Settings</Text>
      <TextInput
        style={styles.input}
        placeholder="Character Name"
        value={name}
        onChangeText={setName}
      />
      <Text style={styles.label}>Class</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setModalVisible(true)}
      >
        <Text>{characterClass}</Text>
      </TouchableOpacity>
      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => {
          setModalVisible(!modalVisible);
        }}
      >
        <View style={styles.modalView}>
          {characterClasses.map((item) => (
            <TouchableOpacity
              key={item}
              style={styles.modalItem}
              onPress={() => {
                setCharacterClass(item);
                setModalVisible(false);
              }}
            >
              <Text>{item}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setModalVisible(false)} />
        </View>
      </Modal>
      <Button title="Save Character" onPress={saveCharacter} />
      {characterList.length > 0 && (
        <View style={styles.characterList}>
          <Text style={styles.label}>Your Characters:</Text>
          {characterList.map((character, index) => (
            <View key={index} style={styles.characterItem}>
              <Text>
                {character.name} - {character.characterClass}
              </Text>
              <Button title="Delete" onPress={() => deleteCharacter(index)} />
            </View>
          ))}
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 20,
    textAlign: "center",
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  label: {
    marginBottom: 10,
    fontSize: 16,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
  characterList: {
    marginTop: 20,
  },
  characterItem: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 10,
  },
});


----- File: screens/CharacterSetupScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Modal,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import Races from "../data/Races";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character";
export default function CharacterSetupScreen({ navigation }) {
  const [name, setName] = useState("");
  const [characterClass, setCharacterClass] = useState("Warrior");
  const [selectedRace, setSelectedRace] = useState("Human");
  const [raceModalVisible, setRaceModalVisible] = useState(false); // Samostatný stav pro modální okno rasy
  const [classModalVisible, setClassModalVisible] = useState(false); // Samostatný stav pro modální okno povolání
  const characterClasses = ["Warrior", "Mage", "Rogue"];
  const raceNames = Object.keys(Races);
  const handleSaveCharacter = async () => {
    const newCharacter = new Character(
      name,
      selectedRace,
      characterClass,
      [], // Natural talents
      [], // Abilities
      [] // Inventory
    );
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      const characters = storedCharacters ? JSON.parse(storedCharacters) : [];
      characters.push(newCharacter);
      await AsyncStorage.setItem("characters", JSON.stringify(characters));
      alert("Character created successfully!");
      navigation.navigate("CharacterSelection");
    } catch (error) {
      console.error("Failed to save character", error);
      alert("There was an error saving the character.");
    }
  };
  return (
    <View style={styles.container}>
      <Text style={styles.label}>Character Name:</Text>
      <TextInput
        style={styles.input}
        value={name}
        onChangeText={setName}
        placeholder="Enter character name"
      />
      <Text style={styles.label}>Race:</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setRaceModalVisible(true)} // Zobrazení modálního okna rasy
      >
        <Text>{selectedRace}</Text>
      </TouchableOpacity>
      <Modal
        animationType="slide"
        transparent={true}
        visible={raceModalVisible}
        onRequestClose={() => setRaceModalVisible(!raceModalVisible)}
      >
        <View style={styles.modalView}>
          {raceNames.map((race) => (
            <TouchableOpacity
              key={race}
              style={styles.modalItem}
              onPress={() => {
                setSelectedRace(race);
                setRaceModalVisible(false);
              }}
            >
              <Text>{race}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setRaceModalVisible(false)} />
        </View>
      </Modal>
      <Text style={styles.label}>Character Class:</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setClassModalVisible(true)} // Zobrazení modálního okna povolání
      >
        <Text>{characterClass}</Text>
      </TouchableOpacity>
      <Modal
        animationType="slide"
        transparent={true}
        visible={classModalVisible}
        onRequestClose={() => setClassModalVisible(!classModalVisible)}
      >
        <View style={styles.modalView}>
          {characterClasses.map((item) => (
            <TouchableOpacity
              key={item}
              style={styles.modalItem}
              onPress={() => {
                setCharacterClass(item);
                setClassModalVisible(false);
              }}
            >
              <Text>{item}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setClassModalVisible(false)} />
        </View>
      </Modal>
      <Button title="Save Character" onPress={handleSaveCharacter} />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});


----- File: screens/CurrentLocationMapScreen.js -----
import React, { useState, useEffect, useRef } from "react";
import {
  View,
  StyleSheet,
  Text,
  Image,
  TouchableOpacity,
  Alert,
  Button,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import GMapModule from "../components/GMapModule";
import * as Location from "expo-location";

export default function CurrentLocationMapScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [points, setPoints] = useState([]);
  const [returnPoint, setReturnPoint] = useState(null);
  const [selectedPointData, setSelectedPointData] = useState(null);
  const [distanceToSelected, setDistanceToSelected] = useState(null);
  const [currentIndex, setCurrentIndex] = useState(0);
  const mapCenterRef = useRef(() => {});

  useEffect(() => {
    const getLocationAndPoints = async () => {
      try {
        let { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== "granted") {
          Alert.alert(
            "Permission denied",
            "Permission to access location was denied"
          );
          return;
        }
        let location = await Location.getCurrentPositionAsync({});
        if (location && location.coords) {
          console.log("Current location:", location.coords);
          setLocation(location.coords);
        } else {
          console.error("Location data is null or undefined");
        }

        const storedPoints = await AsyncStorage.getItem("interestPoints");
        if (storedPoints) {
          const parsedPoints = JSON.parse(storedPoints);
          setPoints(parsedPoints);
        }

        const storedReturnPoint = await AsyncStorage.getItem("returnPoint");
        if (storedReturnPoint) {
          const parsedReturnPoint = JSON.parse(storedReturnPoint);
          setReturnPoint(parsedReturnPoint);
        }
      } catch (error) {
        Alert.alert("Error", "Error getting location or loading points");
        console.error("Error getting location or loading points: ", error);
      }
    };
    getLocationAndPoints();
  }, []);

  const handleMarkerClick = (index, point) => {
    setSelectedPointData(point);
    setCurrentIndex(index);
    if (location) {
      const distance = calculateDistance(
        location.latitude,
        location.longitude,
        point.location.latitude,
        point.location.longitude
      );
      setDistanceToSelected(distance);
    }

    // Zavolání metody pro nastavení středu mapy
    mapCenterRef.current(point.location.latitude, point.location.longitude);
  };

  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3;
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  const handlePreviousPoint = () => {
    if (points.length > 0) {
      const prevIndex = (currentIndex - 1 + points.length) % points.length;
      handleMarkerClick(prevIndex, points[prevIndex]);
    }
  };

  const handleNextPoint = () => {
    if (points.length > 0) {
      const nextIndex = (currentIndex + 1) % points.length;
      handleMarkerClick(nextIndex, points[nextIndex]);
    }
  };

  const handleNavigate = () => {
    if (selectedPointData) {
      navigation.navigate("KompasScreen", { point: selectedPointData });
    }
  };

  const handleCancel = () => {
    setSelectedPointData(null);
    setDistanceToSelected(null);
  };

  return (
    <View style={styles.container}>
      <GMapModule
        points={points}
        returnPoint={returnPoint}
        onMarkerClick={handleMarkerClick}
        setMapCenter={(func) => (mapCenterRef.current = func)}
      />
      {selectedPointData && (
        <View style={styles.infoBox}>
          <View style={styles.infoRow}>
            {selectedPointData.image && (
              <Image
                source={{ uri: selectedPointData.image }}
                style={styles.image}
              />
            )}
            <View style={styles.infoDetails}>
              <Text style={styles.infoText}>
                {selectedPointData.description}
              </Text>
              <Text style={styles.infoText}>
                Souřadnice: {selectedPointData.location.latitude.toFixed(6)},{" "}
                {selectedPointData.location.longitude.toFixed(6)}
              </Text>
              {distanceToSelected && (
                <Text style={styles.infoText}>
                  Vzdálenost: {(distanceToSelected / 1000).toFixed(2)} km
                </Text>
              )}
            </View>
          </View>
          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={styles.button}
              onPress={handlePreviousPoint}
            >
              <Text style={styles.buttonText}>←</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.button} onPress={handleNextPoint}>
              <Text style={styles.buttonText}>→</Text>
            </TouchableOpacity>
          </View>
          <View style={styles.buttonContainer}>
            <Button title="Navigate" onPress={handleNavigate} />
            <Button title="Cancel" onPress={handleCancel} />
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  infoBox: {
    position: "absolute",
    bottom: 20,
    left: 10,
    right: 10,
    backgroundColor: "white",
    padding: 15,
    borderRadius: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    elevation: 5,
  },
  infoRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  infoDetails: {
    flex: 1,
    paddingLeft: 10,
  },
  infoText: {
    fontSize: 14,
    marginBottom: 5,
  },
  image: {
    width: 80,
    height: 80,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 10,
  },
  button: {
    backgroundColor: "#007bff",
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 5,
  },
  buttonText: {
    color: "white",
    fontWeight: "bold",
    textAlign: "center",
  },
});


----- File: screens/DungeonScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, Button, Alert } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character";
import { generateEnemy } from "../utils/generateEnemy";
import standartItems from "../data/standardItems"; // Import standardních položek

const DungeonScreen = ({ route, navigation }) => {
  const { dungeon } = route.params;
  const [character, setCharacter] = useState(null);
  const [enemies, setEnemies] = useState([]);
  const [playerPower, setPlayerPower] = useState(0);
  const [enemyPower, setEnemyPower] = useState(0);
  const [reward, setReward] = useState({ gold: 0, items: [] });

  useEffect(() => {
    const fetchCharacterAndGenerateEnemies = async () => {
      try {
        const storedCharacter = await AsyncStorage.getItem("activeCharacter");
        if (!storedCharacter) {
          throw new Error("Character data not found.");
        }

        const parsedCharacter = JSON.parse(storedCharacter);
        const characterInstance = new Character(
          parsedCharacter.name,
          parsedCharacter.race,
          parsedCharacter.characterClass,
          parsedCharacter.naturalTalents,
          parsedCharacter.abilities,
          parsedCharacter.inventory
        );
        setCharacter(characterInstance);

        const generatedEnemies = [];
        for (let i = 0; i < 3; i++) {
          const enemy = generateEnemy(
            characterInstance.level,
            dungeon.difficulty || "normal",
            dungeon.environment
          );
          generatedEnemies.push(enemy);
        }
        setEnemies(generatedEnemies);

        const playerTotalPower = characterInstance.calculatePower();
        const enemyTotalPower = generatedEnemies.reduce(
          (acc, enemy) => acc + enemy.attack + enemy.defense,
          0
        );

        setPlayerPower(playerTotalPower);
        setEnemyPower(enemyTotalPower);
        calculateReward(playerTotalPower, enemyTotalPower, generatedEnemies);
      } catch (error) {
        console.error("Failed to fetch character or generate enemies", error);
        Alert.alert("Error", "Failed to fetch character or generate enemies");
      }
    };

    fetchCharacterAndGenerateEnemies();
  }, [dungeon]);

  const calculateReward = (playerPower, enemyPower, enemies) => {
    let rewardValue;
    let rewardItems = [];

    if (playerPower > enemyPower) {
      rewardValue = Math.floor(Math.random() * 50) + 50;

      // Přidání náhodného předmětu z standartItems
      const itemTypes = Object.keys(standartItems);
      const randomType =
        itemTypes[Math.floor(Math.random() * itemTypes.length)];
      const randomItem =
        standartItems[randomType][
          Math.floor(Math.random() * standartItems[randomType].length)
        ];
      rewardItems.push(randomItem);

      // Přidání vybavení z nepřátel
      enemies.forEach((enemy) => {
        if (enemy.weapon) rewardItems.push(enemy.weapon);
        if (enemy.armor) rewardItems.push(enemy.armor);
      });
    } else {
      rewardValue = Math.floor(Math.random() * 20) + 10;
    }

    setReward({ gold: rewardValue, items: rewardItems });
  };

  const startExploration = () => {
    let message = `You encountered ${enemies.length} enemies with a total power of ${enemyPower}. Your total power is ${playerPower}.`;

    if (reward.items.length > 0) {
      const itemNames = reward.items.map((item) => item.name).join(", ");
      message += ` You also found: ${itemNames}.`;
    }

    Alert.alert("Dungeon Exploration", message, [
      {
        text: "Fight",
        onPress: async () => {
          if (playerPower > enemyPower) {
            const victoryMessage = `You defeated the enemies, earned ${
              reward.gold
            } gold, and found: ${reward.items
              .map((item) => item.name)
              .join(", ")}!`;

            Alert.alert("Victory!", victoryMessage);
            reward.items.forEach((item) => {
              character.addItemToInventory(item);
            });
            await AsyncStorage.setItem(
              "activeCharacter",
              JSON.stringify(character)
            );
          } else {
            Alert.alert(
              "Defeat!",
              "You were defeated and escaped with nothing."
            );
          }
          navigation.navigate("CharacterSelection");
        },
      },
      {
        text: "Flee",
        onPress: () => navigation.navigate("CharacterSelection"),
      },
    ]);
  };

  return (
    <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>{dungeon.name}</Text>
      <Text style={{ fontSize: 16, marginVertical: 10 }}>
        {dungeon.description}
      </Text>
      <Button title="Start Exploration" onPress={startExploration} />
    </View>
  );
};

export default DungeonScreen;


----- File: screens/EditPointScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  StyleSheet,
  Alert,
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function EditPointScreen({ route, navigation }) {
  const { point } = route.params;
  const [description, setDescription] = useState(point.description || "");
  const [detailedDescription, setDetailedDescription] = useState(
    point.detailedDescription || ""
  );
  const [latitude, setLatitude] = useState(
    point.location.latitude?.toString() || ""
  );
  const [longitude, setLongitude] = useState(
    point.location.longitude?.toString() || ""
  );
  const handleSave = async () => {
    try {
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      let points = storedPoints ? JSON.parse(storedPoints) : [];
      const index = points.findIndex((p) => p.title === point.title);
      if (index !== -1) {
        points[index].description = description;
        points[index].detailedDescription = detailedDescription;
        points[index].location.latitude = parseFloat(latitude);
        points[index].location.longitude = parseFloat(longitude);
        await AsyncStorage.setItem("interestPoints", JSON.stringify(points));
        Alert.alert("Success", "Point updated successfully.");
        navigation.goBack();
      }
    } catch (error) {
      console.error("Error saving point:", error);
      Alert.alert("Error", "There was an error updating the point.");
    }
  };
  const movePoint = (direction) => {
    const distance = 0.0001; // Přibližně 11 metrů
    switch (direction) {
      case "north":
        setLatitude((parseFloat(latitude) + distance).toString());
        break;
      case "south":
        setLatitude((parseFloat(latitude) - distance).toString());
        break;
      case "east":
        setLongitude((parseFloat(longitude) + distance).toString());
        break;
      case "west":
        setLongitude((parseFloat(longitude) - distance).toString());
        break;
      default:
        break;
    }
  };
  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={80}
    >
      <ScrollView contentContainerStyle={styles.scrollViewContainer}>
        <Text style={styles.label}>Description:</Text>
        <TextInput
          style={styles.input}
          value={description}
          onChangeText={setDescription}
        />
        <Text style={styles.label}>Detailed Description:</Text>
        <TextInput
          style={[styles.input, { height: 100 }]}
          value={detailedDescription}
          onChangeText={setDetailedDescription}
          multiline
        />
        <Text style={styles.label}>
          Latitude: {latitude || "Not available"}
        </Text>
        <Text style={styles.label}>
          Longitude: {longitude || "Not available"}
        </Text>
        <View style={styles.buttonContainer}>
          <Button title="Move North" onPress={() => movePoint("north")} />
          <Button title="Move South" onPress={() => movePoint("south")} />
          <Button title="Move East" onPress={() => movePoint("east")} />
          <Button title="Move West" onPress={() => movePoint("west")} />
        </View>
        {point.image && (
          <Image source={{ uri: point.image }} style={styles.image} />
        )}
        <Button title="Save" onPress={handleSave} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollViewContainer: {
    padding: 16,
    flexGrow: 1,
    justifyContent: "space-between",
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 8,
    marginBottom: 16,
    fontSize: 16,
    borderRadius: 4,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 16,
  },
  image: {
    width: 100,
    height: 100,
    marginBottom: 16,
    alignSelf: "center",
  },
});


----- File: screens/EquipmentScreen.js -----
import React from "react";
import { View, Text, Button, StyleSheet, Alert } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function EquipmentScreen({ character, setCharacter }) {
  const handleUnequipItem = async (slot) => {
    const item = character.inventory[slot];
    if (item) {
      Alert.alert("Unequip Item", `Opravdu chcete odvybavit ${item.name}?`, [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Odvybavit",
          onPress: async () => {
            // Remove item from the equipped slot
            const newInventory = [...character.inventory.items];
            newInventory.push({ ...item, equipped: false });
            const updatedCharacter = {
              ...character,
              inventory: {
                ...character.inventory,
                [slot]: null,
                items: newInventory,
              },
            };
            setCharacter(updatedCharacter);
            await AsyncStorage.setItem(
              "character",
              JSON.stringify(updatedCharacter)
            );
            Alert.alert(`${item.name} byl odvybaven a přesunut do inventáře.`);
          },
        },
      ]);
    }
  };
  const renderEquippedItem = (slot, label) => {
    const item = character.inventory[slot];
    if (!item) {
      return <Text style={styles.itemSlotText}>{label}: Žádný předmět</Text>;
    }
    let itemDetails = "";
    switch (item.type) {
      case "weapon":
        itemDetails = `Útok: +${item.properties.attackPoints}`;
        break;
      case "armor":
        itemDetails = `Obrana: +${item.properties.defensePoints}`;
        break;
      case "ring":
      case "amulet":
        itemDetails = `Efekt: +${item.properties.effectAmount}`;
        break;
      default:
        itemDetails = "";
    }
    return (
      <View style={styles.itemSlot}>
        <Text style={styles.itemSlotText}>
          {label}: {item.name} ({itemDetails})
        </Text>
        <Button title="Odvybavit" onPress={() => handleUnequipItem(slot)} />
      </View>
    );
  };
  return (
    <View style={styles.container}>
      {renderEquippedItem("head", "Hlava")}
      {renderEquippedItem("neck", "Krk")}
      {renderEquippedItem("body", "Tělo")}
      {renderEquippedItem("hands[0]", "Levá ruka")}
      {renderEquippedItem("hands[1]", "Pravá ruka")}
      {renderEquippedItem("legs", "Nohy")}
      {renderEquippedItem("feet", "Chodidla")}
      {character.inventory.fingers.map((ring, index) => (
        <View key={index}>
          {renderEquippedItem(`fingers[${index}]`, `Prst (${index + 1})`)}
        </View>
      ))}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#f5f5f5",
  },
  itemSlot: {
    marginBottom: 20,
  },
  itemSlotText: {
    fontSize: 18,
    marginBottom: 10,
  },
});


----- File: screens/HomeScreen.js -----
import React, { useEffect, useState } from "react";
import { View, Text, Button, Alert, ImageBackground } from "react-native";
import styles from "../components/styles"; // Import stylů
import { useFocusEffect } from "@react-navigation/native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useTranslation } from "react-i18next"; // Použij useTranslation hook

export default function HomeScreen({ navigation }) {
  const { t } = useTranslation(); // Inicializace funkce t pro překlady

  const [returnPointSet, setReturnPointSet] = useState(false);
  const [characterSummary, setCharacterSummary] = useState(null);

  useFocusEffect(
    React.useCallback(() => {
      checkReturnPoint();
      loadCharacterSummary();
    }, [])
  );

  const checkReturnPoint = async () => {
    try {
      const returnPoint = await AsyncStorage.getItem("returnPoint");
      setReturnPointSet(!!returnPoint);
    } catch (error) {
      console.error("Error reading return point from AsyncStorage:", error);
      setReturnPointSet(false);
    }
  };

  const loadCharacterSummary = async () => {
    try {
      const storedCharacter = await AsyncStorage.getItem("characters");
      if (storedCharacter) {
        const character = JSON.parse(storedCharacter)[0]; // Zobrazí se první postava
        setCharacterSummary({
          name: character.name,
          race: character.race,
          gender: character.gender || "",
          characterClass: character.characterClass,
          level: character.level || 1,
        });
      }
    } catch (error) {
      console.error("Failed to load character summary", error);
    }
  };

  const setReturnPoint = async () => {
    showConfirmationDialog(
      t("set_return_point_title"),
      t("set_return_point_message"),
      async () => {
        try {
          let { status } = await Location.requestForegroundPermissionsAsync();
          if (status !== "granted") {
            Alert.alert(t("permission_denied"), t("permission_denied_message"));
            return;
          }
          let currentLocation = await Location.getCurrentPositionAsync({});
          const returnPoint = {
            latitude: currentLocation.coords.latitude,
            longitude: currentLocation.coords.longitude,
            title: t("return_point"),
          };
          await AsyncStorage.setItem(
            "returnPoint",
            JSON.stringify(returnPoint)
          );
          console.log("Return point saved:", returnPoint);
          setReturnPointSet(true);
          Alert.alert(t("saved"), t("return_point_saved_message"));
          navigation.navigate("ReturnPointScreen"); // Navigace na ReturnPointScreen
        } catch (error) {
          console.error("Error setting return point:", error);
          Alert.alert(t("error"), t("error_setting_return_point"));
        }
      }
    );
  };

  const showConfirmationDialog = (title, message, onConfirm) => {
    Alert.alert(
      title,
      message,
      [
        {
          text: t("cancel"),
          style: "cancel",
        },
        {
          text: t("yes"),
          onPress: onConfirm,
        },
      ],
      { cancelable: true }
    );
  };

  return (
    <ImageBackground
      source={require("../assets/return.png")}
      style={styles.container}
    >
      <View style={styles.textContainer}>
        <Text style={[styles.title, { color: "#fff", fontSize: 28 }]}>
          {t("explore_capture_title")}
        </Text>
        <Text style={[styles.subtitle, { color: "#fff", fontSize: 20 }]}>
          {t("personal_map_subtitle")}
        </Text>
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={t("set_return_point")}
          //onPress={setReturnPoint}
          onPress={() => navigation.navigate("Return Point")}
          disabled={returnPointSet}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={t("record_interest_point")}
          onPress={() => navigation.navigate("Interest Point")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={t("actions")}
          onPress={() => navigation.navigate("Actions Menu")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={t("view_map")}
          onPress={() => navigation.navigate("DynamicMap")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={t("view_photos")}
          onPress={() => navigation.navigate("Photo Viewer")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={t("settings")}
          onPress={() => navigation.navigate("Settings")}
        />
      </View>
      {characterSummary && (
        <View style={{ marginTop: 20 }}>
          <Text style={{ color: "#fff", fontSize: 18, textAlign: "center" }}>
            {characterSummary.name} {characterSummary.race}{" "}
            {characterSummary.gender ? characterSummary.gender.charAt(0) : ""}{" "}
            {characterSummary.characterClass} Lvl {characterSummary.level}
          </Text>
        </View>
      )}
    </ImageBackground>
  );
}


----- File: screens/InterestPointScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  Switch,
  Alert,
  TextInput,
  Image,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as Location from "expo-location";
import * as ImagePicker from "expo-image-picker";
import * as FileSystem from "expo-file-system";
import * as ImageManipulator from "expo-image-manipulator";
import GpsAccuracyComponent from "../components/GpsAccuracyComponent"; // Radarový indikátor
import { useTranslation } from "react-i18next";

export default function InterestPointScreen({ navigation }) {
  const { t } = useTranslation();
  const [location, setLocation] = useState(null);
  const [image, setImage] = useState(null);
  const [description, setDescription] = useState("");
  const [detailedDescription, setDetailedDescription] = useState("");
  const [isReturnPoint, setIsReturnPoint] = useState(false);
  const [existingReturnPoint, setExistingReturnPoint] = useState(false);
  const [title, setTitle] = useState("");

  useEffect(() => {
    const checkExistingReturnPoint = async () => {
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      const storedReturnPoint = await AsyncStorage.getItem("returnPoint");

      let nextTitleNumber = 1;

      if (storedPoints) {
        const points = JSON.parse(storedPoints);
        const maxTitle = points.reduce(
          (max, point) => Math.max(max, parseInt(point.title)),
          0
        );
        nextTitleNumber = maxTitle + 1;
      }

      if (storedReturnPoint) {
        const returnPoint = JSON.parse(storedReturnPoint);
        setExistingReturnPoint(true);
        nextTitleNumber = Math.max(
          nextTitleNumber,
          parseInt(returnPoint.title) + 1
        );
      }

      setTitle(nextTitleNumber.toString());
    };

    checkExistingReturnPoint();
  }, []);

  const handleLocationDetermined = (coords) => {
    setLocation(coords);
  };

  const pickImage = async () => {
    let result = await ImagePicker.launchCameraAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });
    if (!result.canceled) {
      const manipResult = await ImageManipulator.manipulateAsync(
        result.assets[0].uri,
        [],
        { compress: 0.5, format: ImageManipulator.SaveFormat.JPEG }
      );
      setImage(manipResult.uri);
    } else {
      Alert.alert(
        t("no_image_selected", "No Image"),
        t(
          "image_selection_cancelled",
          "No image was selected or the operation was canceled."
        )
      );
    }
  };

  const saveInterestPoint = async () => {
    if (!location) {
      Alert.alert(
        t("missing_location", "Missing Location"),
        t("set_location_before_saving", "Please set a location before saving.")
      );
      return;
    }
    if (!image) {
      Alert.alert(
        t("missing_image", "Missing Image"),
        t("take_photo_before_saving", "Please take a photo before saving.")
      );
      return;
    }
    if (!description) {
      Alert.alert(
        t("missing_description", "Missing Description"),
        t(
          "enter_description_before_saving",
          "Please enter a description before saving."
        )
      );
      return;
    }

    try {
      const imageName = image.split("/").pop();
      const imagePath = `${FileSystem.documentDirectory}${imageName}`;
      await FileSystem.copyAsync({
        from: image,
        to: imagePath,
      });

      const interestPoint = {
        title,
        location,
        image: imagePath,
        description,
        detailedDescription,
        isReturnPoint,
        timestamp: new Date().toISOString(),
      };

      if (isReturnPoint) {
        // Uložíme návratový bod
        await AsyncStorage.setItem(
          "returnPoint",
          JSON.stringify(interestPoint)
        );
        // Zajistíme, že žádný jiný bod není návratový bod
        const storedPoints = await AsyncStorage.getItem("interestPoints");
        const points = storedPoints ? JSON.parse(storedPoints) : [];
        const updatedPoints = points.map((point) => ({
          ...point,
          isReturnPoint: false,
        }));
        await AsyncStorage.setItem(
          "interestPoints",
          JSON.stringify(updatedPoints)
        );
      } else {
        // Uložíme běžný bod zájmu
        const storedPoints = await AsyncStorage.getItem("interestPoints");
        const points = storedPoints ? JSON.parse(storedPoints) : [];
        points.push(interestPoint);
        await AsyncStorage.setItem("interestPoints", JSON.stringify(points));
      }

      Alert.alert(
        t("saved", "Saved"),
        t("point_saved_successfully", "Point saved successfully!")
      );
      navigation.navigate("Home");
    } catch (error) {
      console.error("Error saving interest point:", error);
      Alert.alert(
        t("error", "Error"),
        t("error_saving_point", "An error occurred while saving the point.")
      );
    }
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
    >
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <GpsAccuracyComponent onLocationDetermined={handleLocationDetermined} />
        {location && (
          <Text style={styles.text}>
            {t("location", "Location")}: {location.latitude},{" "}
            {location.longitude}
          </Text>
        )}
        {existingReturnPoint ? (
          <Text>
            {t("return_point_exists", "Return Point already exists.")}{" "}
            {t(
              "delete_existing_return_point",
              "To set a new one, delete the existing one first."
            )}
          </Text>
        ) : (
          <View style={styles.switchContainer}>
            <Text>{t("set_as_return_point", "Set as Return Point")}</Text>
            <Switch
              value={isReturnPoint}
              onValueChange={setIsReturnPoint}
              disabled={existingReturnPoint}
            />
          </View>
        )}
        <Button title={t("take_photo", "Take a Photo")} onPress={pickImage} />
        {image && <Image source={{ uri: image }} style={styles.image} />}
        <TextInput
          style={styles.input}
          placeholder={t("enter_description", "Enter description")}
          value={description}
          onChangeText={setDescription}
        />
        <TextInput
          style={[styles.input, { height: 80 }]}
          placeholder={t(
            "enter_detailed_description",
            "Enter detailed description"
          )}
          value={detailedDescription}
          onChangeText={setDetailedDescription}
          multiline
        />
        <View style={styles.buttonContainer}>
          <Button
            title={t("save_point", "Save Point")}
            onPress={saveInterestPoint}
          />
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
  },
  scrollContainer: {
    alignItems: "center",
    padding: 16,
  },
  text: {
    marginVertical: 10,
    fontSize: 16,
  },
  image: {
    width: 200,
    height: 200,
    marginVertical: 10,
  },
  input: {
    height: 40,
    borderColor: "gray",
    borderWidth: 1,
    width: "100%",
    paddingHorizontal: 10,
    marginVertical: 10,
  },
  buttonContainer: {
    marginVertical: 10,
    width: "100%",
    alignItems: "center",
  },
  switchContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginVertical: 10,
  },
});


----- File: screens/InventoryScreen.js -----
import React, { useEffect, useState } from "react";
import { View, Text, ScrollView, Button, StyleSheet } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character"; // Importuje třídu Character

const InventoryScreen = ({ navigation }) => {
  const [character, setCharacter] = useState(null);

  useEffect(() => {
    const loadCharacter = async () => {
      try {
        const storedCharacter = await AsyncStorage.getItem("activeCharacter");
        if (storedCharacter) {
          console.log("Stored character found:", storedCharacter);
          const parsedCharacter = JSON.parse(storedCharacter);
          const characterInstance = new Character(
            parsedCharacter.name,
            parsedCharacter.race,
            parsedCharacter.characterClass,
            parsedCharacter.gender,
            parsedCharacter.naturalTalents,
            parsedCharacter.abilities,
            parsedCharacter.inventory
          );
          characterInstance.equipment = parsedCharacter.equipment;
          characterInstance.stats = parsedCharacter.stats;
          characterInstance.level = parsedCharacter.level;
          characterInstance.gold = parsedCharacter.gold;
          characterInstance.mana = parsedCharacter.mana;
          characterInstance.health = parsedCharacter.health;
          characterInstance.healthRegen = parsedCharacter.healthRegen;
          characterInstance.manaRegen = parsedCharacter.manaRegen;
          characterInstance.carryCapacity = parsedCharacter.carryCapacity;
          characterInstance.armorAndWeaponCapacity =
            parsedCharacter.armorAndWeaponCapacity;

          console.log("Active character loaded:", characterInstance);
          setCharacter(characterInstance);
        } else {
          console.log(
            "No active character found. Initializing a new character."
          );
          // Případná inicializace nové postavy zde
          const newCharacter = new Character(
            "New Character",
            "Human",
            "Warrior",
            "Male"
          );
          await AsyncStorage.setItem(
            "activeCharacter",
            JSON.stringify(newCharacter)
          );
          setCharacter(newCharacter);
        }
      } catch (error) {
        console.error("Failed to load character", error);
      }
    };

    loadCharacter();
  }, []);

  const handleEquipItem = async (item) => {
    if (!character) return;

    const success = character.equipItem(item);

    if (success) {
      character.removeItemFromInventory(item); // Odstraní předmět z inventáře, pokud byl úspěšně nasazen
      await AsyncStorage.setItem("activeCharacter", JSON.stringify(character));
      setCharacter({ ...character }); // Aktualizace stavu pro rerender
      console.log("Character after equipping item:", character);
    } else {
      console.log("Failed to equip item:", item.name);
    }
  };

  const handleUnequipItem = async (slot) => {
    if (!character) return;

    const success = character.unequipItem(slot);

    if (success) {
      await AsyncStorage.setItem("activeCharacter", JSON.stringify(character));
      setCharacter({ ...character }); // Aktualizace stavu pro rerender
      console.log(`Item unequipped from ${slot} and added to inventory.`);
    } else {
      console.log(`Failed to unequip item from ${slot}.`);
    }
  };

  return (
    <ScrollView contentContainerStyle={styles.scrollContainer}>
      <View style={styles.container}>
        {character ? (
          <>
            <Text style={styles.title}>Inventory of {character.name}</Text>
            <Text style={styles.sectionTitle}>Equipped Items:</Text>
            {Object.keys(character.equipment).map((slot) => (
              <View key={slot} style={styles.itemSlot}>
                <Text>
                  {slot}: {character.equipment[slot]?.name || "None"}
                </Text>
                {character.equipment[slot] && (
                  <Button
                    title="Unequip"
                    onPress={() => handleUnequipItem(slot)}
                  />
                )}
              </View>
            ))}
            <Text style={styles.sectionTitle}>Inventory:</Text>
            {character.inventory.length > 0 ? (
              character.inventory.map((item, index) => (
                <View key={index.toString()} style={styles.inventoryItem}>
                  <Text>{item.name}</Text>
                  <Button title="Equip" onPress={() => handleEquipItem(item)} />
                </View>
              ))
            ) : (
              <Text>No items in inventory.</Text>
            )}
            <Button
              title="View Book"
              onPress={() => {
                // Odkaz na zobrazení knihy (můžete přidat navigaci na BookScreen)
                navigation.navigate("BookScreen");
              }}
            />
          </>
        ) : (
          <Text>Loading character...</Text>
        )}
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  scrollContainer: {
    paddingBottom: 20,
  },
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
  },
  sectionTitle: {
    fontSize: 20,
    marginTop: 20,
    marginBottom: 10,
    fontWeight: "bold",
  },
  itemSlot: {
    marginBottom: 20,
  },
  inventoryItem: {
    marginBottom: 10,
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 10,
    borderRadius: 5,
  },
});

export default InventoryScreen;


----- File: screens/KompasScreen.js -----
import React, { useState, useEffect } from "react";
import { View, StyleSheet, Image, Text, Button } from "react-native";
import { Magnetometer } from "expo-sensors";
import * as Location from "expo-location";
export default function KompasScreen({ route }) {
  const { point } = route.params;
  const [heading, setHeading] = useState(0);
  const [location, setLocation] = useState(null);
  const [distance, setDistance] = useState(null);
  useEffect(() => {
    const getLocation = async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        return;
      }
      let loc = await Location.getCurrentPositionAsync({});
      setLocation(loc.coords);
      setDistance(
        calculateDistance(
          loc.coords.latitude,
          loc.coords.longitude,
          point.latitude,
          point.longitude
        )
      );
    };
    const _subscribe = () => {
      Magnetometer.addListener((data) => {
        let { x, y } = data;
        let angle = Math.atan2(y, x) * (180 / Math.PI);
        if (angle < 0) {
          angle += 360;
        }
        setHeading(Math.round(angle));
      });
    };
    getLocation();
    _subscribe();
    return () => {
      Magnetometer.removeAllListeners();
    };
  }, [location]);
  const calculateBearing = (lat1, lon1, lat2, lon2) => {
    const toRadians = (deg) => deg * (Math.PI / 180);
    const toDegrees = (rad) => rad * (180 / Math.PI);
    const φ1 = toRadians(lat1);
    const φ2 = toRadians(lat2);
    const Δλ = toRadians(lon2 - lon1);
    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x =
      Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
    let brng = toDegrees(Math.atan2(y, x));
    return (brng + 360) % 360;
  };
  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3; // Poloměr Země v metrech
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // Vzdálenost v metrech
  };
  if (!location) {
    return (
      <View style={styles.container}>
        <Text>Loading...</Text>
      </View>
    );
  }
  const bearing = calculateBearing(
    location.latitude,
    location.longitude,
    point.latitude,
    point.longitude
  );
  const direction = (bearing - heading + 360) % 360;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>
        Aktuální GPS: {location.latitude}, {location.longitude}
      </Text>
      <Text style={styles.text}>
        Cíl GPS: {point.latitude}, {point.longitude}
      </Text>
      <Text style={styles.text}>Směr k cíli: {Math.round(direction)}°</Text>
      <Text style={styles.text}>
        Vzdálenost: {(distance / 1000).toFixed(2)} km
      </Text>
      <Image
        source={require("../assets/arrow.png")} // cesta k obrázku šipky
        style={[styles.arrow, { transform: [{ rotate: `${direction}deg` }] }]}
      />
      <Button
        title="Open Compass App"
        onPress={() => {
          // Zde by byla funkce pro otevření nativní kompasové aplikace
        }}
      />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#f5f5f5",
  },
  text: {
    fontSize: 18,
    marginBottom: 10,
  },
  arrow: {
    width: 200,
    height: 200,
  },
  distanceText: {
    marginTop: 20,
    fontSize: 24,
    color: "#333",
  },
});


----- File: screens/PhotoViewerScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Image,
  Button,
  Alert,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import styles from "../components/styles"; // Import stylů
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as FileSystem from "expo-file-system";
import { Ionicons } from "@expo/vector-icons"; // Import ikon
import { useTranslation } from "react-i18next"; // Použij useTranslation hook

export default function PhotoViewerScreen({ navigation }) {
  const { t } = useTranslation();
  const [currentIndex, setCurrentIndex] = useState(0);
  const [points, setPoints] = useState([]);
  const [returnPoint, setReturnPoint] = useState(null); // Přidáme návratový bod
  const [imageExists, setImageExists] = useState(true);

  useEffect(() => {
    const loadPoints = async () => {
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      const storedReturnPoint = await AsyncStorage.getItem("returnPoint");

      if (storedPoints) {
        const parsedPoints = JSON.parse(storedPoints);
        setPoints(parsedPoints);
        console.log("Loaded points:", parsedPoints);
      }

      if (storedReturnPoint) {
        const parsedReturnPoint = JSON.parse(storedReturnPoint);
        setReturnPoint(parsedReturnPoint);
        console.log("Loaded return point:", parsedReturnPoint);
      }
    };
    loadPoints();
  }, []);

  useEffect(() => {
    const checkImage = async () => {
      const pointToCheck =
        currentIndex < points.length ? points[currentIndex] : returnPoint;

      if (pointToCheck && pointToCheck.image) {
        const fileInfo = await FileSystem.getInfoAsync(pointToCheck.image);
        console.log("Current image info:", fileInfo);
        if (!fileInfo.exists) {
          console.error("Image does not exist:", pointToCheck.image);
          setImageExists(false);
        } else {
          console.log(
            "Image exists and will be displayed:",
            pointToCheck.image
          );
          setImageExists(true);
        }
      }
    };
    checkImage();
  }, [currentIndex, points, returnPoint]);

  const handleNext = () => {
    if (currentIndex < points.length - 1) {
      setCurrentIndex(currentIndex + 1);
    } else if (currentIndex === points.length - 1 && returnPoint) {
      setCurrentIndex(currentIndex + 1);
    } else {
      setCurrentIndex(0);
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    } else if (currentIndex === 0 && returnPoint) {
      setCurrentIndex(points.length);
    } else {
      setCurrentIndex(points.length - 1);
    }
  };

  const handleDelete = async () => {
    Alert.alert(
      t("delete_point", "Delete Point"),
      t(
        "delete_point_confirmation",
        "Are you sure you want to delete this point and its photo?"
      ),
      [
        { text: t("cancel", "Cancel"), style: "cancel" },
        {
          text: t("yes", "Yes"),
          onPress: async () => {
            if (currentIndex < points.length) {
              const updatedPoints = [...points];
              const [removedPoint] = updatedPoints.splice(currentIndex, 1);
              if (removedPoint.image) {
                try {
                  await FileSystem.deleteAsync(removedPoint.image);
                  console.log("Image deleted:", removedPoint.image);
                } catch (error) {
                  console.error("Error deleting image:", error);
                }
              }
              setPoints(updatedPoints);
              await AsyncStorage.setItem(
                "interestPoints",
                JSON.stringify(updatedPoints)
              );
            } else if (currentIndex === points.length) {
              setReturnPoint(null);
              await AsyncStorage.removeItem("returnPoint");
            }

            if (currentIndex >= points.length) {
              setCurrentIndex(points.length - 1);
            }
          },
        },
      ],
      { cancelable: true }
    );
  };

  const handleToggleReturnPoint = async () => {
    const selectedPoint =
      currentIndex < points.length ? points[currentIndex] : returnPoint;

    if (selectedPoint.isReturnPoint) {
      // Pokud je bod návratovým bodem, přeměníme ho na běžný bod
      selectedPoint.isReturnPoint = false;
      setPoints((prevPoints) => [...prevPoints, selectedPoint]);
      setReturnPoint(null);
      await AsyncStorage.removeItem("returnPoint");
      await AsyncStorage.setItem("interestPoints", JSON.stringify(points));
    } else {
      // Pokud není návratový bod, nastavíme ho a zrušíme status z aktuálního return pointu
      if (returnPoint) {
        returnPoint.isReturnPoint = false;
        setPoints((prevPoints) => [...prevPoints, returnPoint]);
        await AsyncStorage.setItem("interestPoints", JSON.stringify(points));
      }

      selectedPoint.isReturnPoint = true;
      setReturnPoint(selectedPoint);
      setPoints((prevPoints) =>
        prevPoints.filter((point, index) => index !== currentIndex)
      );
      await AsyncStorage.setItem("returnPoint", JSON.stringify(selectedPoint));
      await AsyncStorage.setItem(
        "interestPoints",
        JSON.stringify(points.filter((_, index) => index !== currentIndex))
      );
    }
  };

  if (points.length === 0 && !returnPoint) {
    return (
      <View style={styles.container}>
        <Text style={styles.message}>
          {t("no_points_found", "No interest points found.")}
        </Text>
        <View style={styles.buttonContainer}>
          <Button
            title={t("back", "Back")}
            onPress={() => navigation.goBack()}
          />
        </View>
      </View>
    );
  }

  const currentPoint =
    currentIndex < points.length ? points[currentIndex] : returnPoint;

  const isToggleDisabled = currentPoint.isReturnPoint ? false : !!returnPoint; // Povolit přepínač jen pokud je to návratový bod nebo žádný návratový bod neexistuje.

  return (
    <View style={styles.container}>
      <View style={localStyles.navigationContainer}>
        <TouchableOpacity
          onPress={handlePrevious}
          style={localStyles.navButton}
        >
          <Ionicons name="chevron-back-circle" size={30} color="black" />
          <Text style={localStyles.navText}>{t("previous", "Previous")}</Text>
        </TouchableOpacity>
        <TouchableOpacity onPress={handleNext} style={localStyles.navButton}>
          <Text style={localStyles.navText}>{t("next", "Next")}</Text>
          <Ionicons name="chevron-forward-circle" size={30} color="black" />
        </TouchableOpacity>
      </View>
      {imageExists ? (
        <Image source={{ uri: currentPoint.image }} style={localStyles.image} />
      ) : (
        <Text>{t("no_image_available", "No image available")}</Text>
      )}
      <Text style={styles.text}>
        {t("description", "Description")}: {currentPoint.description}
      </Text>
      <Text style={styles.text}>
        {t("location", "Location")}: {currentPoint.location.latitude},{" "}
        {currentPoint.location.longitude}
      </Text>
      <View style={styles.buttonContainer}>
        <Button
          title={t("delete_point", "Delete Point")}
          onPress={handleDelete}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button title={t("back", "Back")} onPress={() => navigation.goBack()} />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title={
            currentPoint.isReturnPoint
              ? t("make_interest_point", "Make Interest Point")
              : t("make_return_point", "Make Return Point")
          }
          onPress={handleToggleReturnPoint}
          disabled={isToggleDisabled} // Přepínač je deaktivovaný, pokud už existuje návratový bod a aktuální bod není návratovým bodem
        />
      </View>
    </View>
  );
}

const localStyles = StyleSheet.create({
  navigationContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 10,
    width: "100%",
    paddingHorizontal: 20,
  },
  navButton: {
    flexDirection: "row",
    alignItems: "center",
  },
  navText: {
    fontSize: 16,
    marginHorizontal: 5,
  },
  image: {
    width: "100%",
    height: 300,
    resizeMode: "contain",
    marginBottom: 10,
  },
});


----- File: screens/PlaceObjectScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Modal,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Keyboard,
  TouchableWithoutFeedback,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Picker } from "@react-native-picker/picker";
import {
  standardWeapons,
  standardArmor,
  standardAccessories,
  standardPotions,
  standardScrolls,
  specialObjects,
} from "../data/standardItems";

export default function PlaceObjectScreen({ navigation }) {
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [type, setType] = useState("weapon");
  const [slot, setSlot] = useState(null);
  const [properties, setProperties] = useState({});
  const [modalVisible, setModalVisible] = useState(false);

  const handlePlaceObject = async () => {
    try {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        alert("Permission to access location was denied");
        return;
      }
      const location = await Location.getCurrentPositionAsync({});
      const newObject = {
        name,
        description,
        type,
        slot,
        properties,
        location: {
          latitude: location.coords.latitude,
          longitude: location.coords.longitude,
        },
      };
      const storedObjects = await AsyncStorage.getItem("placedObjects");
      const placedObjects = storedObjects ? JSON.parse(storedObjects) : [];
      placedObjects.push(newObject);
      await AsyncStorage.setItem(
        "placedObjects",
        JSON.stringify(placedObjects)
      );
      alert("Object placed successfully!");
      navigation.goBack();
    } catch (error) {
      console.error("Error placing object:", error);
      alert("There was an error placing the object.");
    }
  };

  const objectTypes = [
    { label: "Weapon", value: "weapon" },
    { label: "Armor", value: "armor" },
    { label: "Accessory", value: "accessory" },
    { label: "Potion", value: "potion" },
    { label: "Scroll", value: "scroll" },
    { label: "Special", value: "special" },
  ];

  const getItemsByType = (selectedType) => {
    switch (selectedType) {
      case "weapon":
        return standardWeapons;
      case "armor":
        return standardArmor;
      case "accessory":
        return standardAccessories;
      case "potion":
        return standardPotions;
      case "scroll":
        return standardScrolls;
      case "special":
        return specialObjects;
      default:
        return [];
    }
  };

  const handleTypeChange = (selectedType) => {
    setType(selectedType);
    setProperties({});
    const items = getItemsByType(selectedType);
    if (items.length > 0) {
      const defaultItem = items[0];
      setName(defaultItem.name);
      setProperties(defaultItem.properties);
      setSlot(defaultItem.slot);
    }
  };

  const renderPropertiesInput = () => {
    switch (type) {
      case "weapon":
        return (
          <>
            <Text style={styles.label}>Weapon Type:</Text>
            <Picker
              selectedValue={name}
              onValueChange={(value) => {
                const selectedWeapon = standardWeapons.find(
                  (weapon) => weapon.name === value
                );
                setName(selectedWeapon.name);
                setProperties(selectedWeapon.properties);
                setSlot(selectedWeapon.slot);
              }}
            >
              {standardWeapons.map((weapon) => (
                <Picker.Item
                  key={weapon.name}
                  label={weapon.name}
                  value={weapon.name}
                />
              ))}
            </Picker>
            <Text style={styles.label}>Weight: {properties.weight}</Text>
            <Text style={styles.label}>
              Attack Points: {properties.attackPoints}
            </Text>
            <Text style={styles.label}>
              Defense Points: {properties.defensePoints || 0}
            </Text>
          </>
        );
      case "armor":
        return (
          <>
            <Text style={styles.label}>Armor Type:</Text>
            <Picker
              selectedValue={name}
              onValueChange={(value) => {
                const selectedArmor = standardArmor.find(
                  (armor) => armor.name === value
                );
                setName(selectedArmor.name);
                setProperties(selectedArmor.properties);
                setSlot(selectedArmor.slot);
              }}
            >
              {standardArmor.map((armor) => (
                <Picker.Item
                  key={armor.name}
                  label={armor.name}
                  value={armor.name}
                />
              ))}
            </Picker>
            <Text style={styles.label}>Weight: {properties.weight}</Text>
            <Text style={styles.label}>
              Defense Points: {properties.defensePoints}
            </Text>
          </>
        );
      // Similar case for accessories, potions, scrolls, etc.
      default:
        return null;
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <Text style={styles.label}>Object Name:</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Enter object name"
        />
        <Text style={styles.label}>Object Description:</Text>
        <TextInput
          style={styles.input}
          value={description}
          onChangeText={setDescription}
          placeholder="Enter object description"
          multiline
        />
        <Text style={styles.label}>Object Type:</Text>
        <TouchableOpacity
          style={styles.picker}
          onPress={() => setModalVisible(true)}
        >
          <Text>{objectTypes.find((item) => item.value === type)?.label}</Text>
        </TouchableOpacity>
        <Modal
          animationType="slide"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => setModalVisible(!modalVisible)}
        >
          <View style={styles.modalView}>
            {objectTypes.map((item) => (
              <TouchableOpacity
                key={item.value}
                style={styles.modalItem}
                onPress={() => {
                  handleTypeChange(item.value);
                  setModalVisible(false);
                }}
              >
                <Text>{item.label}</Text>
              </TouchableOpacity>
            ))}
            <Button title="Cancel" onPress={() => setModalVisible(false)} />
          </View>
        </Modal>
        {renderPropertiesInput()}
        <Button title="Place Object" onPress={handlePlaceObject} />
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});


----- File: screens/PointScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  ActivityIndicator,
  Alert,
} from "react-native";
import { useTranslation } from "react-i18next";
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as Location from "expo-location";
import MapView, { Marker } from "react-native-maps";
import { averageGpsCoordinates } from "../components/gpsUtils";

export default function PointScreen({ navigation, route }) {
  const { t } = useTranslation();
  const [location, setLocation] = useState(null);
  const [loading, setLoading] = useState(false);
  const [errorMsg, setErrorMsg] = useState(null);
  const { pointType } = route.params || {};

  const recalculateGps = async () => {
    setLoading(true);
    try {
      const averagedCoords = await averageGpsCoordinates();
      setLocation(averagedCoords);
    } catch (error) {
      setErrorMsg(error.message);
    }
    setLoading(false);
  };

  useEffect(() => {
    recalculateGps();
  }, []);

  const saveAndGoBack = async () => {
    if (location) {
      const key = `${pointType}_${Date.now()}`;
      await AsyncStorage.setItem(key, JSON.stringify(location));
      Alert.alert(t("save_success"), t("save_success_message"));
      navigation.goBack(); // Návrat zpět po uložení
    } else {
      Alert.alert(t("save_error"), t("save_error_message"));
    }
  };

  if (loading) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#0000ff" />
        <Text>{t("calculating_gps")}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {errorMsg ? (
        <Text style={styles.error}>{errorMsg}</Text>
      ) : (
        <View style={{ flex: 1, width: "100%" }}>
          <MapView
            style={styles.map}
            region={{
              latitude: location ? location.latitude : 0,
              longitude: location ? location.longitude : 0,
              latitudeDelta: 0.01,
              longitudeDelta: 0.01,
            }}
            showsUserLocation={true}
            onRegionChangeComplete={(region) => setLocation(region)}
          >
            {location && (
              <Marker
                coordinate={{
                  latitude: location.latitude,
                  longitude: location.longitude,
                }}
                title={pointType || t("return_point")}
              />
            )}
          </MapView>
          <View style={styles.controls}>
            <Button title={t("recalculate_gps")} onPress={recalculateGps} />
            <Button title={t("save_point")} onPress={saveAndGoBack} />{" "}
            {/* Upraveno tlačítko */}
            <Button title={t("go_back")} onPress={() => navigation.goBack()} />
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  error: {
    color: "red",
  },
  map: {
    width: "100%",
    height: "50%",
  },
  controls: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
});


----- File: screens/ReturnPointScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  ActivityIndicator,
  Alert,
} from "react-native";
import { useNavigation } from "@react-navigation/native";
import { averageGpsCoordinates } from "../components/gpsUtils"; // Import průměrovací funkce
import MapView, { Marker } from "react-native-maps";
import { useTranslation } from "react-i18next"; // Import the useTranslation hook

export default function ReturnPointScreen() {
  const { t } = useTranslation(); // Initialize t

  const [location, setLocation] = useState(null);
  const [loading, setLoading] = useState(false);
  const [errorMsg, setErrorMsg] = useState(null);
  const navigation = useNavigation();

  const recalculateGps = async () => {
    setLoading(true);
    try {
      const averagedCoords = await averageGpsCoordinates();
      setLocation(averagedCoords);
    } catch (error) {
      setErrorMsg(error.message);
    }
    setLoading(false);
  };

  useEffect(() => {
    recalculateGps();
  }, []);

  return (
    <View style={styles.container}>
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0000ff" />
          <Text>{t("calculating_gps")}</Text>
        </View>
      ) : errorMsg ? (
        <Text style={styles.error}>{errorMsg}</Text>
      ) : (
        <View style={styles.content}>
          <Text>
            {t("gps_coordinates")}:{" "}
            {location
              ? `${location.latitude}, ${location.longitude}`
              : t("no_coordinates")}
          </Text>
          <View style={styles.mapContainer}>
            <MapView
              style={styles.map}
              region={{
                latitude: location ? location.latitude : 0,
                longitude: location ? location.longitude : 0,
                latitudeDelta: 0.01,
                longitudeDelta: 0.01,
              }}
              showsUserLocation={true}
              onRegionChangeComplete={(region) => setLocation(region)}
            >
              {location && (
                <Marker
                  coordinate={{
                    latitude: location.latitude,
                    longitude: location.longitude,
                  }}
                  title={t("return_point")}
                />
              )}
            </MapView>
          </View>
          <View style={styles.buttonContainer}>
            <Button title={t("recalculate_gps")} onPress={recalculateGps} />
            <Button
              title={t("view_point")}
              onPress={() =>
                navigation.navigate("PointScreen", { pointType: "Return" })
              }
            />
            <Button title={t("go_back")} onPress={() => navigation.goBack()} />
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  loadingContainer: {
    alignItems: "center",
  },
  content: {
    alignItems: "center",
    width: "100%",
  },
  mapContainer: {
    height: "50%", // Mapa zabere horní polovinu obrazovky
    width: "100%",
    marginVertical: 20,
  },
  buttonContainer: {
    marginTop: 20,
    width: "100%",
    justifyContent: "space-between",
    alignItems: "center",
  },
  error: {
    color: "red",
  },
  map: {
    width: "100%",
    height: "100%",
  },
});


----- File: screens/SearchAreaScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  ScrollView,
  Alert,
  TouchableWithoutFeedback,
  Keyboard,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character";
import Book from "../models/Book"; // Import knihy
import { standardItems } from "../data/standardItems";

function SearchAreaScreen({ navigation }) {
  const [foundObjects, setFoundObjects] = useState([]);
  const [character, setCharacter] = useState(null);

  // Funkce na výpočet vzdálenosti mezi dvěma body (v metrech)
  const getDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3; // Poloměr Země v metrech
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon1 - lon2) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  useEffect(() => {
    const searchArea = async () => {
      try {
        let { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== "granted") {
          alert("Permission to access location was denied");
          return;
        }
        const location = await Location.getCurrentPositionAsync({});
        const storedObjects = await AsyncStorage.getItem("placedObjects");
        const placedObjects = storedObjects ? JSON.parse(storedObjects) : [];
        const nearbyObjects = placedObjects.filter(
          (obj) =>
            getDistance(
              obj.location.latitude,
              obj.location.longitude,
              location.coords.latitude,
              location.coords.longitude
            ) <= 10 // Hledání v okruhu 10 metrů
        );
        setFoundObjects(nearbyObjects);

        const storedCharacters = await AsyncStorage.getItem("characters");
        if (storedCharacters) {
          const characters = JSON.parse(storedCharacters);
          const activeCharacter = characters.find((char) => char.isActive);
          if (activeCharacter) {
            setCharacter(
              new Character(
                activeCharacter.name,
                activeCharacter.race,
                activeCharacter.characterClass
              )
            );
            console.log("Active character loaded:", activeCharacter);
          } else {
            Alert.alert(
              "No active character",
              "Please select or create a character."
            );
            navigation.goBack();
          }
        } else {
          Alert.alert(
            "No characters found",
            "Please create a character first."
          );
          navigation.goBack();
        }
      } catch (error) {
        console.error("Error searching area or loading character:", error);
      }
    };
    searchArea();
  }, []);

  const handleActionButtonPress = async (object) => {
    try {
      if (!character) {
        console.log("Character not found in handleActionButtonPress");
        throw new Error(
          "No character found. Please select or create a character."
        );
      }

      if (object.slot === "special") {
        if (object.type === "dungeon") {
          navigation.navigate("DungeonScreen", { dungeon: object });
        } else if (object.type === "inscription") {
          const book = new Book();
          const storedEntries = await AsyncStorage.getItem("bookEntries");
          const entries = storedEntries ? JSON.parse(storedEntries) : [];
          book.entries = entries;

          // Kontrola, zda již zápis existuje
          const existingEntry = book.entries.find(
            (entry) => entry.name === object.name
          );

          if (!existingEntry) {
            book.addEntry(object);
            await AsyncStorage.setItem(
              "bookEntries",
              JSON.stringify(book.getEntries())
            );
            console.log("New inscription added to the book:", object);
          } else {
            console.log("Inscription already exists in the book:", object);
          }
        }
        return;
      }

      // Přidání předmětu do inventáře bez kontroly na duplicity
      character.inventory.push(object);
      console.log("Added item to inventory:", object);

      // Uložit aktualizovaný charakter do AsyncStorage
      await AsyncStorage.setItem("activeCharacter", JSON.stringify(character));

      // Odstranění předmětu z mapy
      const storedObjects = await AsyncStorage.getItem("placedObjects");
      let placedObjects = storedObjects ? JSON.parse(storedObjects) : [];
      placedObjects = placedObjects.filter(
        (obj) =>
          !(
            obj.name === object.name &&
            obj.location.latitude === object.location.latitude &&
            obj.location.longitude === object.location.longitude
          )
      );
      await AsyncStorage.setItem(
        "placedObjects",
        JSON.stringify(placedObjects)
      );
      setFoundObjects(placedObjects);
      console.log("Item removed from map:", object);
    } catch (error) {
      console.error("Error handling action button press:", error);
      Alert.alert("There was an error processing the action.");
    }
  };

  const getActionButtonTitle = (object) => {
    if (object.slot === "special") {
      if (object.type === "dungeon") {
        return "Enter Dungeon";
      } else if (object.type === "inscription") {
        return "Add to Book";
      }
    }
    return "Save to Inventory";
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        {character && (
          <View style={styles.characterContainer}>
            <Text style={styles.characterName}>
              Active Character: {character.name}
            </Text>
            <Text>Class: {character.characterClass}</Text>
            <Text>Level: {character.level}</Text>
          </View>
        )}
        {foundObjects.length > 0 ? (
          <ScrollView>
            {foundObjects.map((object, index) => (
              <View key={index} style={styles.objectContainer}>
                <Text style={styles.label}>You found:</Text>
                <Text style={styles.objectName}>{object.name}</Text>
                <Text style={styles.objectDescription}>
                  {object.description}
                </Text>
                <Button
                  title={getActionButtonTitle(object)}
                  onPress={() => handleActionButtonPress(object)}
                />
              </View>
            ))}
          </ScrollView>
        ) : (
          <Text style={styles.label}>Nothing found in the area.</Text>
        )}
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    justifyContent: "center",
    alignItems: "center",
  },
  characterContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
    alignItems: "center",
  },
  characterName: {
    fontSize: 20,
    fontWeight: "bold",
  },
  objectContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  objectName: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 8,
  },
  objectDescription: {
    fontSize: 16,
    marginBottom: 16,
  },
});

export default SearchAreaScreen;


----- File: screens/SettingsScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  Alert,
  TouchableOpacity,
  Linking,
  StyleSheet,
} from "react-native";
import { Picker } from "@react-native-picker/picker";
import styles from "../components/styles";
import { importData } from "../components/importData";
import { exportData } from "../components/exportData";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function SettingsScreen({ navigation }) {
  const [selectedMode, setSelectedMode] = useState("Herní režim");
  const [loading, setLoading] = useState(false);
  const handleModeChange = (mode) => {
    setSelectedMode(mode);
    Alert.alert("Režim změněn", `Aktuální režim je nyní: ${mode}`);
  };
  const deleteAllData = async () => {
    Alert.alert(
      "Smazat všechna data?",
      "Opravdu chcete smazat všechna data? Tato akce je nevratná.",
      [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Ano",
          onPress: async () => {
            try {
              await AsyncStorage.clear();
              Alert.alert("Úspěch", "Všechna data byla smazána.");
            } catch (error) {
              Alert.alert("Chyba", "Došlo k chybě při mazání dat.");
              console.error("Delete error:", error);
            }
          },
        },
      ],
      { cancelable: true }
    );
  };
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Settings</Text>
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Mode Settings</Text>
        <View style={styles.pickerContainer}>
          <Picker
            selectedValue={selectedMode}
            style={styles.picker}
            onValueChange={(itemValue) => handleModeChange(itemValue)}
          >
            <Picker.Item label="Herní režim" value="Herní režim" />
            <Picker.Item label="Výletní režim" value="Výletní režim" />
            <Picker.Item label="Admin režim" value="Admin režim" />
          </Picker>
        </View>
      </View>
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Data Management</Text>
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Export Data"
          onPress={() => exportData(setLoading)}
          disabled={loading}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Import Data"
          onPress={() => importData(setLoading)}
          disabled={loading}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="Delete All Data" onPress={deleteAllData} />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="About" onPress={() => navigation.navigate("About")} />
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={localStyles.aboutButton}
          onPress={() =>
            Linking.openURL("https://www.facebook.com/groups/461720089986492")
          }
        >
          <Text style={localStyles.aboutButtonText}>
            VentureOut Facebook Group
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}
// Přidání stylů pro tlačítko About
const localStyles = StyleSheet.create({
  aboutButton: {
    backgroundColor: "#007bff",
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 5,
    marginTop: 10,
  },
  aboutButtonText: {
    color: "white",
    fontWeight: "bold",
    textAlign: "center",
  },
});


===== Directory: data =====
----- File: data/CharacterAttributes.js -----
const CharacterAttributes = {
  genderModifiers: {
    Male: {
      strength: 1,
      speed: 0,
      agility: 0,
    },
    Female: {
      strength: -1,
      speed: 1,
      agility: 1,
    },
  },
};
export default CharacterAttributes;


----- File: data/CharacterClasses.js -----
const CharacterClasses = {
  Warrior: {
    name: "Warrior",
    description: "A strong and brave fighter, skilled in melee combat.",
    strength: 3,
    defense: 2,
    attack: 2,
    speed: 0,
    mana: -10,
    health: 20,
  },
  Mage: {
    name: "Mage",
    description: "A master of the arcane, powerful in magic.",
    strength: 0,
    defense: 0,
    attack: 1,
    speed: 0,
    mana: 30,
    health: -10,
  },
  Rogue: {
    name: "Rogue",
    description: "A stealthy and agile character, skilled in evasion.",
    strength: 1,
    defense: 0,
    attack: 2,
    speed: 3,
    mana: 0,
    health: 0,
  },
};
export default CharacterClasses;


----- File: data/Races.js -----
class Race {
  constructor(name, traits, attributeModifiers) {
    this.name = name;
    this.traits = traits; // Pole vlastností, např. Darkvision
    this.attributeModifiers = attributeModifiers; // Objekt obsahující modifikátory atributů
  }
}

// Definice ras v souladu s tvými požadavky
export const Races = {
  Human: new Race("Human", ["Versatile"], {
    strength: 9, // Base Attack = 9
    attack: 2,
    defense: 4, // Base Defense = 4
    speed: 8, // Base Speed = 8
    luck: 2, // Mírný bonus k štěstí
    courage: 5, // Mírný bonus ke kuráži
    magic: 1, // Základní magie
  }),
  Orc: new Race("Orc", ["Savage Attacks", "Menacing"], {
    strength: 14, // Velká síla
    defense: 10, // Vysoká obrana
    attack: 5,
    speed: 6, // Pomalejší pohyb
    luck: 1,
    courage: 8, // Velká kuráž
    magic: 0, // Žádná magie
  }),
  Elf: new Race("Elf", ["Darkvision", "Keen Senses"], {
    strength: 8, // Nižší síla než u lidí
    defense: 5, // Vyšší obrana než u lidí
    attack: 2,
    speed: 10, // Rychlejší než lidé a trpaslíci
    luck: 3, // Vyšší štěstí
    courage: 6, // Odvážní, ale méně než orci
    magic: 10, // Silná magie
  }),
  Dwarf: new Race("Dwarf", ["Darkvision", "Resilience"], {
    strength: 12, // Silnější než lidé, ale slabší než orci
    defense: 12, // Vysoká obrana
    attack: 3,
    speed: 7, // Pomalejší než elfové
    luck: 2, // Základní štěstí
    courage: 7, // Odvážní a houževnatí
    magic: 2, // Základní znalosti magie
  }),
};

export default Race;


----- File: data/standardItems.js -----
export const standardWeapons = [
  {
    name: "Short Sword",
    properties: {
      attackPoints: 3,
      defensePoints: 1,
      weight: 2,
    },
    slot: "hand",
  },
  {
    name: "Long Sword",
    properties: {
      attackPoints: 5,
      defensePoints: 2,
      weight: 4,
    },
    slot: "hand",
  },
  {
    name: "Rapier",
    properties: {
      attackPoints: 4,
      defensePoints: 1,
      weight: 3,
    },
    slot: "hand",
  },
  {
    name: "Battle Axe",
    properties: {
      attackPoints: 6,
      defensePoints: 2,
      weight: 5,
    },
    slot: "hand",
  },
  {
    name: "War Hammer",
    properties: {
      attackPoints: 7,
      defensePoints: 3,
      weight: 6,
    },
    slot: "hand",
  },
];

export const standardArmor = [
  {
    name: "Leather Armor",
    properties: {
      defensePoints: 2,
      weight: 5,
    },
    slot: "body",
  },
  {
    name: "Chainmail Armor",
    properties: {
      defensePoints: 4,
      weight: 10,
    },
    slot: "body",
  },
  {
    name: "Plate Armor",
    properties: {
      defensePoints: 6,
      weight: 15,
    },
    slot: "body",
  },
  {
    name: "Shield",
    properties: {
      defensePoints: 2,
      weight: 4,
    },
    slot: "hand",
  },
  {
    name: "Iron Helmet",
    properties: {
      defensePoints: 3,
      weight: 3,
    },
    slot: "head",
  },
  {
    name: "Iron Leggings",
    properties: {
      defensePoints: 4,
      weight: 6,
    },
    slot: "legs",
  },
  {
    name: "Leather Boots",
    properties: {
      defensePoints: 1,
      weight: 2,
    },
    slot: "feet",
  },
];

export const standardAccessories = [
  {
    name: "Ring of Strength",
    properties: {
      strength: 2,
      weight: 0.1,
    },
    slot: "finger",
  },
  {
    name: "Ring of Agility",
    properties: {
      agility: 2,
      weight: 0.1,
    },
    slot: "finger",
  },

  {
    name: "Amulet of Protection",
    properties: {
      defensePoints: 3,
      weight: 0.2,
    },
    slot: "neck",
  },
  {
    name: "Ring of Speed",
    properties: {
      speed: 2,
      weight: 0.1,
    },
    slot: "finger",
  },
];

export const standardPotions = [
  {
    name: "Potion of Healing",
    properties: {
      healingPoints: 20,
      weight: 0.5,
    },
    slot: "consumable",
  },
  {
    name: "Potion of Strength",
    properties: {
      strength: 3,
      weight: 0.5,
    },
    slot: "consumable",
  },
];

export const standardScrolls = [
  {
    name: "Scroll of Fireball",
    properties: {
      magicDamage: 15,
      weight: 0.3,
    },
    slot: "consumable",
  },
  {
    name: "Scroll of Healing",
    properties: {
      healingPoints: 20,
      weight: 0.3,
    },
    slot: "consumable",
  },
];

export const specialObjects = [
  {
    name: "Dungeon Entrance",
    properties: {
      type: "dungeon",
      weight: 0,
    },
    slot: "special",
  },
  {
    name: "Engraving",
    properties: {
      type: "inscription",
      weight: 0,
    },
    slot: "special",
  },
];


===== Directory: utils =====
----- File: utils/generateEnemy.js -----


