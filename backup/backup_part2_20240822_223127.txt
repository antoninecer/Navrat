===== Directory: screens =====
----- File: screens/AboutScreen.js -----
import React from "react";
import { View, Text, ScrollView, StyleSheet } from "react-native";

export default function AboutScreen() {
  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>About Return</Text>
      <Text style={styles.paragraph}>
        Welcome to Return! Our system for character creation and attribute
        management is inspired by Dungeons & Dragons (D&D), but with some key
        differences and simplifications.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Attributes:</Text>
        {"\n"}D&D uses six main attributes (Strength, Dexterity, Constitution,
        Intelligence, Wisdom, Charisma) that influence various aspects of a
        character, such as combat abilities, skills, magic, and resilience.
        {"\n"}Our system uses similar attributes but they are reduced in number
        and have simpler applications. For example, our attributes include
        Strength, Defense, Attack, Speed, Luck, Courage, which is a mix of
        physical and mental characteristics.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Races and Classes:</Text>
        {"\n"}In D&D, a character's race and class have complex interactions
        where the race provides specific bonuses to attributes, and the class
        determines skills, abilities, spells, and hit points (HP). Each
        race-class combination can lead to very different characters with
        various strengths and weaknesses.
        {"\n"}In our system, race and class also provide bonuses to attributes,
        but our classes do not directly affect base attributes (e.g., magic,
        speed). Instead, the class defines the basic role and can influence
        skills and special abilities of the character in a simpler and less
        modular way than in D&D.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Generating Attributes:</Text>
        {"\n"}In D&D, attributes are usually generated by rolling dice (e.g.,
        4d6 and keeping the highest three values), adding an element of
        randomness and imbalance between characters.
        {"\n"}Our system has predefined attribute values based on race and class
        choices. This ensures greater balance and predictability but also limits
        diversity.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Leveling Up:</Text>
        {"\n"}In D&D, as a character levels up, they can increase their
        attributes and gain new abilities, spells, and skills. This process is
        highly detailed, allowing players to customize their characters to suit
        their play style.
        {"\n"}In our system, leveling up would also allow attributes to be
        increased and new abilities to be gained, but likely with less emphasis
        on skills and more on core attributes and simple abilities.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Complexity and Flexibility:</Text>
        {"\n"}D&D is very flexible and complex, allowing players to create and
        customize their characters in various styles and stories. This
        complexity, however, can be challenging for new players.
        {"\n"}Our system is simplified to be more accessible and easier to
        implement. It offers fewer customization options but is also less
        complicated and easier to understand and manage.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Equipment and Spells:</Text>
        {"\n"}In D&D, different types of equipment and spells have very specific
        and varying effects, often with complex rules on how they interact with
        each other.
        {"\n"}Our system likely simplifies equipment and spells, making their
        effects easier to manage and understand.
      </Text>
      <Text style={styles.paragraph}>
        <Text style={styles.subtitle}>Conclusion:</Text>
        {"\n"}Our system is simplified and tailored for quick implementation and
        easy use, while D&D is complex and offers much greater depth for
        advanced players who want to customize every aspect of their character.
        The simplifications we have made ensure that the game remains accessible
        and fun without being burdened by too much complexity.
      </Text>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 20,
  },
  paragraph: {
    fontSize: 16,
    marginBottom: 15,
  },
  subtitle: {
    fontWeight: "bold",
    fontSize: 18,
  },
});


----- File: screens/ActionsMenuScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, Button } from "react-native";
import styles from "../components/styles";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function ActionsMenuScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [characterExists, setCharacterExists] = useState(false);

  useEffect(() => {
    const checkCharacter = async () => {
      try {
        const storedCharacters = await AsyncStorage.getItem("characters");
        console.log("Stored characters:", storedCharacters);

        if (storedCharacters) {
          const characters = JSON.parse(storedCharacters);
          const activeCharacter = characters.find((char) => char.isActive);
          setCharacterExists(!!activeCharacter);
          console.log("Active character exists:", !!activeCharacter);
        } else {
          setCharacterExists(false);
        }
      } catch (error) {
        console.error("Error checking character:", error);
      }
    };

    const updateLocation = async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        console.log("Permission to access location was denied");
        return;
      }
      const loc = await Location.getCurrentPositionAsync({});
      setLocation({
        latitude: loc.coords.latitude,
        longitude: loc.coords.longitude,
      });
    };

    checkCharacter();
    const intervalId = setInterval(updateLocation, 2000);
    return () => clearInterval(intervalId);
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Actions</Text>
      {location ? (
        <Text style={styles.coords}>
          Latitude: {location.latitude.toFixed(6)}
          {"\n"}
          Longitude: {location.longitude.toFixed(6)}
        </Text>
      ) : (
        <Text style={styles.coords}>Loading GPS coordinates...</Text>
      )}

      <View style={styles.buttonContainer}>
        <Button
          title="Place Object"
          onPress={() => navigation.navigate("Place Object")}
        />
      </View>

      <View style={styles.buttonContainer}>
        <Button
          title="Search Area"
          onPress={() => navigation.navigate("Search Area")}
        />
      </View>

      <View style={styles.buttonContainer}>
        <Button
          title="View Inventory"
          onPress={() => navigation.navigate("Inventory")}
        />
      </View>

      <View style={styles.buttonContainer}>
        <Button
          title="View Tasks"
          onPress={() => navigation.navigate("Tasks")}
        />
      </View>

      <View style={styles.buttonContainer}>
        <Button
          title={characterExists ? "Select Character" : "Create Character"}
          onPress={() => navigation.navigate("CharacterSelection")}
        />
      </View>

      <View style={styles.buttonContainer}>
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
    </View>
  );
}


----- File: screens/BookScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, ScrollView, StyleSheet } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function BookScreen({ navigation }) {
  const [entries, setEntries] = useState([]);

  useEffect(() => {
    const loadEntries = async () => {
      try {
        const storedEntries = await AsyncStorage.getItem("bookEntries");
        const bookEntries = storedEntries ? JSON.parse(storedEntries) : [];
        setEntries(bookEntries);
      } catch (error) {
        console.error("Error loading book entries:", error);
      }
    };

    loadEntries();
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Your Book</Text>
      <ScrollView>
        {entries.length > 0 ? (
          entries.map((entry, index) => (
            <View key={index} style={styles.entryContainer}>
              <Text style={styles.entryTitle}>{entry.name}</Text>
              <Text style={styles.entryText}>{entry.description}</Text>
            </View>
          ))
        ) : (
          <Text style={styles.noEntries}>Your book is empty.</Text>
        )}
      </ScrollView>
      <Button title="Back" onPress={() => navigation.goBack()} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 16,
    textAlign: "center",
  },
  entryContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
  },
  entryTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 8,
  },
  entryText: {
    fontSize: 16,
  },
  noEntries: {
    fontSize: 18,
    textAlign: "center",
    marginTop: 20,
  },
});


----- File: screens/CharacterCreationScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  TouchableOpacity,
  StyleSheet,
  Modal,
  TextInput,
  TouchableWithoutFeedback,
  Keyboard,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage"; // Správný import

import Races from "../data/Races";
import CharacterClasses from "../data/CharacterClasses";

const CharacterCreationScreen = ({ navigation }) => {
  const [name, setName] = useState("");
  const [selectedRace, setSelectedRace] = useState(null);
  const [selectedGender, setSelectedGender] = useState(null);
  const [selectedClass, setSelectedClass] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [isSelectingRace, setIsSelectingRace] = useState(true);
  const [isSelectingGender, setIsSelectingGender] = useState(false);
  const [isSelectingClass, setIsSelectingClass] = useState(false);
  const [characterAttributes, setCharacterAttributes] = useState({
    strength: 0,
    defense: 0,
    attack: 0,
    speed: 0,
    luck: 0,
    courage: 0,
    mana: 50,
    health: 100,
    level: 1, // Nastavujeme počáteční úroveň postavy
  });

  const handleSelectRace = (race) => {
    setSelectedRace(race);
    setCharacterAttributes({
      ...characterAttributes,
      strength: race.strength,
      defense: race.defense,
      attack: race.attack,
      speed: race.speed,
      luck: race.luck,
      courage: race.courage,
    });
    setIsSelectingRace(false);
    setIsSelectingGender(true);
    setModalVisible(false);
  };

  const handleSelectGender = (gender) => {
    setSelectedGender(gender);
    const genderModifier =
      gender === "Female" ? { strength: -1, speed: 1 } : {};
    setCharacterAttributes({
      ...characterAttributes,
      strength: characterAttributes.strength + (genderModifier.strength || 0),
      speed: characterAttributes.speed + (genderModifier.speed || 0),
    });
    setIsSelectingGender(false);
    setIsSelectingClass(true);
    setModalVisible(false);
  };

  const handleSelectClass = (characterClass) => {
    setSelectedClass(characterClass);
    const classAttributes = CharacterClasses[characterClass];
    setCharacterAttributes({
      ...characterAttributes,
      strength: characterAttributes.strength + classAttributes.strength,
      defense: characterAttributes.defense + classAttributes.defense,
      attack: characterAttributes.attack + classAttributes.attack,
      speed: characterAttributes.speed + classAttributes.speed,
      mana: characterAttributes.mana + classAttributes.mana,
      health: characterAttributes.health + classAttributes.health,
    });
    setIsSelectingClass(false);
    setModalVisible(false);
  };

  const handleSaveCharacter = async () => {
    if (!selectedRace || !selectedGender || !selectedClass) {
      alert("Please select a race, gender, and class.");
      return;
    }

    const newCharacter = {
      name,
      race: selectedRace.name,
      gender: selectedGender,
      characterClass: selectedClass,
      ...characterAttributes,
    };

    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      const characters = storedCharacters ? JSON.parse(storedCharacters) : [];
      characters.push(newCharacter);
      await AsyncStorage.setItem("characters", JSON.stringify(characters));
      navigation.navigate("CharacterSelection");
    } catch (error) {
      console.error("Failed to save character", error);
      alert("There was an error saving the character.");
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <Text style={styles.label}>Character Name:</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Enter character name"
        />

        <View style={styles.buttonSpacing}>
          <Button
            title="Select Race"
            onPress={() => {
              setIsSelectingRace(true);
              setModalVisible(true);
            }}
          />
        </View>

        {selectedRace && (
          <>
            <View style={styles.detailsContainer}>
              <Text>Selected Race: {selectedRace.name}</Text>
              <Text>Description: {selectedRace.description}</Text>
              <Text>Strength: {characterAttributes.strength}</Text>
              <Text>Defense: {characterAttributes.defense}</Text>
              <Text>Attack: {characterAttributes.attack}</Text>
              <Text>Speed: {characterAttributes.speed}</Text>
              <Text>Luck: {characterAttributes.luck}</Text>
              <Text>Courage: {characterAttributes.courage}</Text>
              <Text>Health: {characterAttributes.health}</Text>
              <Text>Mana: {characterAttributes.mana}</Text>
            </View>
            <View style={styles.buttonSpacing}>
              <Button
                title="Select Gender"
                onPress={() => {
                  setIsSelectingGender(true);
                  setModalVisible(true);
                }}
              />
            </View>
          </>
        )}

        {selectedGender && (
          <>
            <View style={styles.detailsContainer}>
              <Text>Selected Gender: {selectedGender}</Text>
            </View>
            <View style={styles.buttonSpacing}>
              <Button
                title="Select Class"
                onPress={() => {
                  setIsSelectingClass(true);
                  setModalVisible(true);
                }}
              />
            </View>
          </>
        )}

        {selectedClass && (
          <View style={styles.detailsContainer}>
            <Text>Selected Class: {selectedClass}</Text>
          </View>
        )}

        <View style={styles.buttonSpacing}>
          <Button title="Save Character" onPress={handleSaveCharacter} />
        </View>

        <Modal
          animationType="slide"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => setModalVisible(false)}
        >
          <View style={styles.modalView}>
            {isSelectingRace
              ? Object.values(Races).map((race) => (
                  <TouchableOpacity
                    key={race.name}
                    style={styles.modalItem}
                    onPress={() => handleSelectRace(race)}
                  >
                    <Text>{race.name}</Text>
                  </TouchableOpacity>
                ))
              : isSelectingGender
              ? ["Male", "Female"].map((gender) => (
                  <TouchableOpacity
                    key={gender}
                    style={styles.modalItem}
                    onPress={() => handleSelectGender(gender)}
                  >
                    <Text>{gender}</Text>
                  </TouchableOpacity>
                ))
              : Object.keys(CharacterClasses).map((characterClass) => (
                  <TouchableOpacity
                    key={characterClass}
                    style={styles.modalItem}
                    onPress={() => handleSelectClass(characterClass)}
                  >
                    <Text>{characterClass}</Text>
                  </TouchableOpacity>
                ))}
            <Button title="Cancel" onPress={() => setModalVisible(false)} />
          </View>
        </Modal>
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  detailsContainer: {
    marginTop: 16,
  },
  buttonSpacing: {
    marginVertical: 10,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});

export default CharacterCreationScreen;


----- File: screens/CharacterDetailScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  Alert,
  ScrollView,
} from "react-native";

export default function CharacterDetailScreen({ route }) {
  const { character } = route.params;
  const [inventory, setInventory] = useState(
    initializeInventory(character.inventory)
  );

  function initializeInventory(inventory = {}) {
    return {
      head: inventory.head || null,
      neck: inventory.neck || null,
      body: inventory.body || null,
      hands: inventory.hands || [null, null],
      legs: inventory.legs || null,
      feet: inventory.feet || null,
      fingers: inventory.fingers || Array(10).fill(null),
      items: inventory.items || [],
    };
  }

  const handleUnequipItem = (slot, index = null) => {
    const updatedInventory = { ...inventory };
    if (index !== null) {
      updatedInventory[slot][index] = null;
    } else {
      updatedInventory[slot] = null;
    }
    setInventory(updatedInventory);
    Alert.alert("Item removed", `The item from ${slot} was unequipped.`);
  };

  const handleEquipItem = (item, slot, index = null) => {
    if (!slot) {
      Alert.alert("Cannot Equip", "This item cannot be equipped to any slot.");
      return;
    }

    const updatedInventory = { ...inventory };
    if (index !== null) {
      updatedInventory[slot][index] = item;
    } else {
      updatedInventory[slot] = item;
    }
    setInventory(updatedInventory);
    Alert.alert("Item equipped", `${item.name} was equipped to ${slot}.`);
  };

  const renderEquippedItem = (slot, label, index = null) => {
    const item = index !== null ? inventory[slot][index] : inventory[slot];
    return (
      <View style={styles.itemSlot}>
        <Text style={styles.itemSlotText}>
          {label}: {item ? item.name : "None"}
        </Text>
        {item && (
          <Button
            title="Remove"
            onPress={() => handleUnequipItem(slot, index)}
          />
        )}
      </View>
    );
  };

  return (
    <ScrollView contentContainerStyle={styles.scrollContainer}>
      <View style={styles.container}>
        <Text style={styles.title}>{character.name}</Text>
        <Text>Race: {character.race}</Text>
        <Text>Class: {character.characterClass}</Text>
        <Text>Level: {character.level}</Text>
        <Text>Health: {character.health}</Text>
        <Text>Mana: {character.mana}</Text>

        <Text style={styles.sectionTitle}>Equipped Items:</Text>
        {renderEquippedItem("head", "Head")}
        {renderEquippedItem("neck", "Neck")}
        {renderEquippedItem("body", "Body")}
        {renderEquippedItem("hands", "Left Hand", 0)}
        {renderEquippedItem("hands", "Right Hand", 1)}
        {renderEquippedItem("legs", "Legs")}
        {renderEquippedItem("feet", "Feet")}
        {inventory.fingers.map((ring, index) => (
          <View key={index}>
            {renderEquippedItem("fingers", `Finger (${index + 1})`, index)}
          </View>
        ))}

        <Text style={styles.sectionTitle}>Inventory:</Text>
        {inventory.items.map((item) => (
          <View key={item.id} style={styles.inventoryItem}>
            <Text>{item.name}</Text>
            <Button
              title="Equip"
              onPress={() => handleEquipItem(item, item.slot)}
            />
          </View>
        ))}
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  scrollContainer: {
    paddingBottom: 20, // Přidání spodního paddingu pro posuvnost
  },
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
  },
  sectionTitle: {
    fontSize: 20,
    marginTop: 20,
    marginBottom: 10,
    fontWeight: "bold",
  },
  itemSlot: {
    marginBottom: 20,
  },
  itemSlotText: {
    fontSize: 18,
    marginBottom: 10,
  },
  inventoryItem: {
    marginBottom: 10,
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 10,
    borderRadius: 5,
  },
});


----- File: screens/CharacterEquipmentScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Alert,
} from "react-native";

export default function CharacterEquipmentScreen({ route }) {
  const { character } = route.params;
  const [inventory, setInventory] = useState(
    initializeInventory(character.inventory)
  );
  const [selectedSlot, setSelectedSlot] = useState(null);

  function initializeInventory(inventory = {}) {
    return {
      head: inventory.head || null,
      neck: inventory.neck || null,
      body: inventory.body || null,
      hands: inventory.hands || [null, null],
      legs: inventory.legs || null,
      feet: inventory.feet || null,
      fingers: inventory.fingers || Array(10).fill(null),
      items: inventory.items || [],
    };
  }

  const handleEquipItem = (item) => {
    const updatedInventory = { ...inventory };
    if (selectedSlot.index !== null) {
      updatedInventory[selectedSlot.slot][selectedSlot.index] = item;
    } else {
      updatedInventory[selectedSlot.slot] = item;
    }
    setInventory(updatedInventory);
    setSelectedSlot(null);
    Alert.alert(
      "Item equipped",
      `${item.name} was equipped to ${selectedSlot.label}.`
    );
  };

  const renderSlot = (label, slot, index = null) => {
    const item = index !== null ? inventory[slot][index] : inventory[slot];
    return (
      <TouchableOpacity
        style={styles.slot}
        onPress={() => setSelectedSlot({ slot, index, label })}
      >
        <Text style={styles.slotLabel}>{label}</Text>
        <Text>{item ? item.name : "None"}</Text>
      </TouchableOpacity>
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{character.name}</Text>
      <Text>Level: {character.level}</Text>

      {/* Vizuální zobrazení těla */}
      <View style={styles.bodyContainer}>
        <View style={styles.upperBody}>
          {renderSlot("Head", "head")}
          {renderSlot("Neck", "neck")}
          {renderSlot("Body", "body")}
        </View>
        <View style={styles.hands}>
          {renderSlot("Left Hand", "hands", 0)}
          {renderSlot("Right Hand", "hands", 1)}
        </View>
        <View style={styles.lowerBody}>
          {renderSlot("Legs", "legs")}
          {renderSlot("Feet", "feet")}
        </View>
      </View>

      {/* Inventář pro vybavení */}
      {selectedSlot && (
        <View style={styles.inventoryContainer}>
          <Text>Equip item to {selectedSlot.label}:</Text>
          <FlatList
            data={inventory.items}
            keyExtractor={(item) => item.id.toString()}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.inventoryItem}
                onPress={() => handleEquipItem(item)}
              >
                <Text>{item.name}</Text>
              </TouchableOpacity>
            )}
          />
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#f5f5f5",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 16,
  },
  bodyContainer: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  upperBody: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "80%",
  },
  hands: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    marginTop: 20,
  },
  lowerBody: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "80%",
    marginTop: 20,
  },
  slot: {
    alignItems: "center",
    justifyContent: "center",
    padding: 10,
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 5,
    backgroundColor: "#fff",
    marginVertical: 5,
  },
  slotLabel: {
    fontWeight: "bold",
  },
  inventoryContainer: {
    padding: 16,
    backgroundColor: "#fff",
    borderTopWidth: 1,
    borderColor: "#ccc",
  },
  inventoryItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderColor: "#ccc",
  },
});


----- File: screens/CharacterSelectionScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";

const CharacterSelectionScreen = ({ navigation }) => {
  const [characters, setCharacters] = useState([]);
  const [activeCharacter, setActiveCharacter] = useState(null);

  useEffect(() => {
    const unsubscribe = navigation.addListener("focus", () => {
      loadCharacters();
    });
    return unsubscribe;
  }, [navigation]);

  const loadCharacters = async () => {
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      if (storedCharacters) {
        const parsedCharacters = JSON.parse(storedCharacters);
        setCharacters(parsedCharacters);
        const activeChar = parsedCharacters.find((char) => char.isActive);
        setActiveCharacter(activeChar);
      }
    } catch (error) {
      console.error("Failed to load characters", error);
    }
  };

  const selectCharacter = async (character) => {
    // Označení vybrané postavy jako aktivní
    const updatedCharacters = characters.map((char) => ({
      ...char,
      isActive: char.name === character.name,
    }));
    setCharacters(updatedCharacters);
    await AsyncStorage.setItem("characters", JSON.stringify(updatedCharacters));

    setActiveCharacter(character);
    console.log("Selected character:", character);
    navigation.navigate("CharacterDetail", { character }); // Předání vybrané postavy do CharacterDetailScreen
  };

  const createCharacter = () => {
    // Přesměrování na obrazovku pro vytvoření postavy
    navigation.navigate("CharacterCreation");
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Select Your Character</Text>
      {characters.length > 0 ? (
        <FlatList
          data={characters}
          keyExtractor={(item, index) => index.toString()}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={[
                styles.characterItem,
                item.isActive && styles.activeCharacterItem,
              ]}
              onPress={() => selectCharacter(item)}
            >
              <Text>
                {item.name} - {item.characterClass}{" "}
                {item.isActive ? "(Active)" : ""}
              </Text>
            </TouchableOpacity>
          )}
        />
      ) : (
        <View style={styles.noCharacterContainer}>
          <Text style={styles.noCharacterText}>No characters found.</Text>
          <Button title="Create Character" onPress={createCharacter} />
        </View>
      )}
      <Button title="Back" onPress={() => navigation.goBack()} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 20,
    textAlign: "center",
  },
  characterItem: {
    padding: 10,
    marginVertical: 8,
    backgroundColor: "#f9f9f9",
    borderColor: "#ddd",
    borderWidth: 1,
    borderRadius: 5,
  },
  activeCharacterItem: {
    backgroundColor: "#d0f0c0", // Zelenější barva pro označení aktivní postavy
  },
  noCharacterContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  noCharacterText: {
    fontSize: 18,
    marginBottom: 20,
  },
});

export default CharacterSelectionScreen;


----- File: screens/CharacterSettingsScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Alert,
  Modal,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function CharacterSettingsScreen({ navigation }) {
  const [name, setName] = useState("");
  const [characterClass, setCharacterClass] = useState("Warrior");
  const [characterList, setCharacterList] = useState([]);
  const [modalVisible, setModalVisible] = useState(false);

  useEffect(() => {
    loadCharacters();
  }, []);

  const loadCharacters = async () => {
    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      if (storedCharacters) {
        setCharacterList(JSON.parse(storedCharacters));
      }
    } catch (error) {
      console.error("Failed to load characters", error);
    }
  };

  const saveCharacter = async () => {
    try {
      const newCharacter = { name, characterClass };
      const updatedCharacterList = [...characterList, newCharacter];
      setCharacterList(updatedCharacterList);
      await AsyncStorage.setItem(
        "characters",
        JSON.stringify(updatedCharacterList)
      );
      Alert.alert("Success", "Character saved!");
    } catch (error) {
      console.error("Failed to save character", error);
      Alert.alert("Error", "Failed to save character");
    }
  };

  const deleteCharacter = async (index) => {
    try {
      const updatedCharacterList = characterList.filter((_, i) => i !== index);
      setCharacterList(updatedCharacterList);
      await AsyncStorage.setItem(
        "characters",
        JSON.stringify(updatedCharacterList)
      );
      Alert.alert("Success", "Character deleted!");
    } catch (error) {
      console.error("Failed to delete character", error);
      Alert.alert("Error", "Failed to delete character");
    }
  };

  const characterClasses = ["Warrior", "Mage", "Rogue"]; // Přidat další třídy podle potřeby

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Character Settings</Text>

      <TextInput
        style={styles.input}
        placeholder="Character Name"
        value={name}
        onChangeText={setName}
      />

      <Text style={styles.label}>Class</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setModalVisible(true)}
      >
        <Text>{characterClass}</Text>
      </TouchableOpacity>

      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => {
          setModalVisible(!modalVisible);
        }}
      >
        <View style={styles.modalView}>
          {characterClasses.map((item) => (
            <TouchableOpacity
              key={item}
              style={styles.modalItem}
              onPress={() => {
                setCharacterClass(item);
                setModalVisible(false);
              }}
            >
              <Text>{item}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setModalVisible(false)} />
        </View>
      </Modal>

      <Button title="Save Character" onPress={saveCharacter} />

      {characterList.length > 0 && (
        <View style={styles.characterList}>
          <Text style={styles.label}>Your Characters:</Text>
          {characterList.map((character, index) => (
            <View key={index} style={styles.characterItem}>
              <Text>
                {character.name} - {character.characterClass}
              </Text>
              <Button title="Delete" onPress={() => deleteCharacter(index)} />
            </View>
          ))}
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  title: {
    fontSize: 24,
    marginBottom: 20,
    textAlign: "center",
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  label: {
    marginBottom: 10,
    fontSize: 16,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
  characterList: {
    marginTop: 20,
  },
  characterItem: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 10,
  },
});


----- File: screens/CharacterSetupScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Modal,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import Races from "../data/Races";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Character from "../models/Character";

export default function CharacterSetupScreen({ navigation }) {
  const [name, setName] = useState("");
  const [characterClass, setCharacterClass] = useState("Warrior");
  const [selectedRace, setSelectedRace] = useState("Human");
  const [raceModalVisible, setRaceModalVisible] = useState(false); // Samostatný stav pro modální okno rasy
  const [classModalVisible, setClassModalVisible] = useState(false); // Samostatný stav pro modální okno povolání

  const characterClasses = ["Warrior", "Mage", "Rogue"];
  const raceNames = Object.keys(Races);

  const handleSaveCharacter = async () => {
    const newCharacter = new Character(
      name,
      selectedRace,
      characterClass,
      [], // Natural talents
      [], // Abilities
      [] // Inventory
    );

    try {
      const storedCharacters = await AsyncStorage.getItem("characters");
      const characters = storedCharacters ? JSON.parse(storedCharacters) : [];
      characters.push(newCharacter);
      await AsyncStorage.setItem("characters", JSON.stringify(characters));
      alert("Character created successfully!");
      navigation.navigate("CharacterSelection");
    } catch (error) {
      console.error("Failed to save character", error);
      alert("There was an error saving the character.");
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Character Name:</Text>
      <TextInput
        style={styles.input}
        value={name}
        onChangeText={setName}
        placeholder="Enter character name"
      />

      <Text style={styles.label}>Race:</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setRaceModalVisible(true)} // Zobrazení modálního okna rasy
      >
        <Text>{selectedRace}</Text>
      </TouchableOpacity>

      <Modal
        animationType="slide"
        transparent={true}
        visible={raceModalVisible}
        onRequestClose={() => setRaceModalVisible(!raceModalVisible)}
      >
        <View style={styles.modalView}>
          {raceNames.map((race) => (
            <TouchableOpacity
              key={race}
              style={styles.modalItem}
              onPress={() => {
                setSelectedRace(race);
                setRaceModalVisible(false);
              }}
            >
              <Text>{race}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setRaceModalVisible(false)} />
        </View>
      </Modal>

      <Text style={styles.label}>Character Class:</Text>
      <TouchableOpacity
        style={styles.picker}
        onPress={() => setClassModalVisible(true)} // Zobrazení modálního okna povolání
      >
        <Text>{characterClass}</Text>
      </TouchableOpacity>

      <Modal
        animationType="slide"
        transparent={true}
        visible={classModalVisible}
        onRequestClose={() => setClassModalVisible(!classModalVisible)}
      >
        <View style={styles.modalView}>
          {characterClasses.map((item) => (
            <TouchableOpacity
              key={item}
              style={styles.modalItem}
              onPress={() => {
                setCharacterClass(item);
                setClassModalVisible(false);
              }}
            >
              <Text>{item}</Text>
            </TouchableOpacity>
          ))}
          <Button title="Cancel" onPress={() => setClassModalVisible(false)} />
        </View>
      </Modal>

      <Button title="Save Character" onPress={handleSaveCharacter} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});


----- File: screens/CurrentLocationMapScreen.js -----
import React, { useState, useEffect, useRef } from "react";
import {
  View,
  StyleSheet,
  Text,
  Image,
  TouchableOpacity,
  Alert,
  Button,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import GMapModule from "../components/GMapModule";
import * as Location from "expo-location";
export default function CurrentLocationMapScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [points, setPoints] = useState([]);
  const [returnPoint, setReturnPoint] = useState(null);
  const [selectedPointData, setSelectedPointData] = useState(null);
  const [distanceToSelected, setDistanceToSelected] = useState(null);
  const [currentIndex, setCurrentIndex] = useState(0);
  const mapCenterRef = useRef(() => {});
  useEffect(() => {
    const getLocationAndPoints = async () => {
      try {
        let { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== "granted") {
          Alert.alert(
            "Permission denied",
            "Permission to access location was denied"
          );
          return;
        }
        let location = await Location.getCurrentPositionAsync({});
        setLocation(location.coords);
        const storedPoints = await AsyncStorage.getItem("interestPoints");
        if (storedPoints) {
          const parsedPoints = JSON.parse(storedPoints);
          setPoints(parsedPoints);
        }
        const storedReturnPoint = await AsyncStorage.getItem("returnPoint");
        if (storedReturnPoint) {
          const parsedReturnPoint = JSON.parse(storedReturnPoint);
          setReturnPoint(parsedReturnPoint);
        }
      } catch (error) {
        Alert.alert("Error", "Error getting location or loading points");
        console.error("Error getting location or loading points: ", error);
      }
    };
    getLocationAndPoints();
  }, []);
  const handleMarkerClick = (index, point) => {
    setSelectedPointData(point);
    setCurrentIndex(index);
    if (location) {
      const distance = calculateDistance(
        location.latitude,
        location.longitude,
        point.location.latitude,
        point.location.longitude
      );
      setDistanceToSelected(distance);
    }
    // Zavolání metody pro nastavení středu mapy
    mapCenterRef.current(point.location.latitude, point.location.longitude);
  };
  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3;
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };
  const handlePreviousPoint = () => {
    if (points.length > 0) {
      const prevIndex = (currentIndex - 1 + points.length) % points.length;
      handleMarkerClick(prevIndex, points[prevIndex]);
    }
  };
  const handleNextPoint = () => {
    if (points.length > 0) {
      const nextIndex = (currentIndex + 1) % points.length;
      handleMarkerClick(nextIndex, points[nextIndex]);
    }
  };
  const handleNavigate = () => {
    if (selectedPointData) {
      navigation.navigate("KompasScreen", { point: selectedPointData });
    }
  };
  const handleCancel = () => {
    setSelectedPointData(null);
    setDistanceToSelected(null);
  };
  return (
    <View style={styles.container}>
      <GMapModule
        points={points}
        returnPoint={returnPoint}
        onMarkerClick={handleMarkerClick}
        setMapCenter={(func) => (mapCenterRef.current = func)}
      />
      {selectedPointData && (
        <View style={styles.infoBox}>
          <View style={styles.infoRow}>
            {selectedPointData.image && (
              <Image
                source={{ uri: selectedPointData.image }}
                style={styles.image}
              />
            )}
            <View style={styles.infoDetails}>
              <Text style={styles.infoText}>
                {selectedPointData.description}
              </Text>
              <Text style={styles.infoText}>
                Souřadnice: {selectedPointData.location.latitude.toFixed(6)},{" "}
                {selectedPointData.location.longitude.toFixed(6)}
              </Text>
              {distanceToSelected && (
                <Text style={styles.infoText}>
                  Vzdálenost: {(distanceToSelected / 1000).toFixed(2)} km
                </Text>
              )}
            </View>
          </View>
          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={styles.button}
              onPress={handlePreviousPoint}
            >
              <Text style={styles.buttonText}>←</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.button} onPress={handleNextPoint}>
              <Text style={styles.buttonText}>→</Text>
            </TouchableOpacity>
          </View>
          <View style={styles.buttonContainer}>
            <Button title="Navigate" onPress={handleNavigate} />
            <Button title="Cancel" onPress={handleCancel} />
          </View>
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  infoBox: {
    position: "absolute",
    bottom: 20,
    left: 10,
    right: 10,
    backgroundColor: "white",
    padding: 15,
    borderRadius: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    elevation: 5,
  },
  infoRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  infoDetails: {
    flex: 1,
    paddingLeft: 10,
  },
  infoText: {
    fontSize: 14,
    marginBottom: 5,
  },
  image: {
    width: 80,
    height: 80,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 10,
  },
  button: {
    backgroundColor: "#007bff",
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 5,
  },
  buttonText: {
    color: "white",
    fontWeight: "bold",
    textAlign: "center",
  },
});


----- File: screens/DungeonScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, Button, Alert } from "react-native";
import { getCharacter } from "../models/characterModel";
import { generateEnemy } from "../utils/generateEnemy";

const DungeonScreen = ({ route, navigation }) => {
  const { dungeon } = route.params;

  const [character, setCharacter] = useState(null);
  const [enemies, setEnemies] = useState([]);
  const [playerPower, setPlayerPower] = useState(0);
  const [enemyPower, setEnemyPower] = useState(0);
  const [reward, setReward] = useState(null);

  useEffect(() => {
    const fetchCharacterAndGenerateEnemies = async () => {
      try {
        const fetchedCharacter = await getCharacter();
        if (!fetchedCharacter) {
          throw new Error("Character data not found.");
        }

        setCharacter(fetchedCharacter);

        const generatedEnemies = [];
        for (let i = 0; i < 3; i++) {
          const enemy = generateEnemy(
            fetchedCharacter.level,
            dungeon.difficulty || "normal",
            dungeon.environment
          );
          generatedEnemies.push(enemy);
        }
        setEnemies(generatedEnemies);

        calculatePowers(fetchedCharacter, generatedEnemies);
      } catch (error) {
        console.error("Failed to fetch character or generate enemies", error);
        Alert.alert("Error", "Failed to fetch character or generate enemies");
      }
    };

    fetchCharacterAndGenerateEnemies();
  }, []);

  const calculatePowers = (character, enemies) => {
    if (!character || !enemies.length) return;

    const playerTotalPower =
      character.strength +
      character.defense +
      character.attack +
      character.speed;
    const enemyTotalPower = enemies.reduce(
      (acc, enemy) => acc + enemy.attack + enemy.defense,
      0
    );

    setPlayerPower(playerTotalPower);
    setEnemyPower(enemyTotalPower);

    calculateReward(playerTotalPower, enemyTotalPower);
  };

  const calculateReward = (playerPower, enemyPower) => {
    let rewardValue;
    if (playerPower > enemyPower) {
      rewardValue = Math.floor(Math.random() * 50) + 50;
    } else {
      rewardValue = Math.floor(Math.random() * 20) + 10;
    }
    setReward({ gold: rewardValue });
  };

  const startExploration = () => {
    Alert.alert(
      "Dungeon Exploration",
      `You encountered ${enemies.length} enemies with a total power of ${enemyPower}. Your total power is ${playerPower}.`,
      [
        {
          text: "Fight",
          onPress: () => {
            if (playerPower > enemyPower) {
              Alert.alert(
                "Victory!",
                `You defeated the enemies and earned ${reward.gold} gold!`
              );
            } else {
              Alert.alert(
                "Defeat!",
                "You were defeated and escaped with nothing."
              );
            }
            navigation.navigate("CharacterSelection");
          },
        },
        {
          text: "Flee",
          onPress: () => navigation.navigate("CharacterSelection"),
        },
      ]
    );
  };

  return (
    <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
      <Text style={{ fontSize: 24, fontWeight: "bold" }}>{dungeon.name}</Text>
      <Text style={{ fontSize: 16, marginVertical: 10 }}>
        {dungeon.description}
      </Text>
      <Button title="Start Exploration" onPress={startExploration} />
    </View>
  );
};

export default DungeonScreen;


----- File: screens/EditPointScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  StyleSheet,
  Alert,
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function EditPointScreen({ route, navigation }) {
  const { point } = route.params;
  const [description, setDescription] = useState(point.description || "");
  const [detailedDescription, setDetailedDescription] = useState(
    point.detailedDescription || ""
  );
  const [latitude, setLatitude] = useState(
    point.location.latitude?.toString() || ""
  );
  const [longitude, setLongitude] = useState(
    point.location.longitude?.toString() || ""
  );
  const handleSave = async () => {
    try {
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      let points = storedPoints ? JSON.parse(storedPoints) : [];
      const index = points.findIndex((p) => p.title === point.title);
      if (index !== -1) {
        points[index].description = description;
        points[index].detailedDescription = detailedDescription;
        points[index].location.latitude = parseFloat(latitude);
        points[index].location.longitude = parseFloat(longitude);
        await AsyncStorage.setItem("interestPoints", JSON.stringify(points));
        Alert.alert("Success", "Point updated successfully.");
        navigation.goBack();
      }
    } catch (error) {
      console.error("Error saving point:", error);
      Alert.alert("Error", "There was an error updating the point.");
    }
  };
  const movePoint = (direction) => {
    const distance = 0.0001; // Přibližně 11 metrů
    switch (direction) {
      case "north":
        setLatitude((parseFloat(latitude) + distance).toString());
        break;
      case "south":
        setLatitude((parseFloat(latitude) - distance).toString());
        break;
      case "east":
        setLongitude((parseFloat(longitude) + distance).toString());
        break;
      case "west":
        setLongitude((parseFloat(longitude) - distance).toString());
        break;
      default:
        break;
    }
  };
  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={80}
    >
      <ScrollView contentContainerStyle={styles.scrollViewContainer}>
        <Text style={styles.label}>Description:</Text>
        <TextInput
          style={styles.input}
          value={description}
          onChangeText={setDescription}
        />
        <Text style={styles.label}>Detailed Description:</Text>
        <TextInput
          style={[styles.input, { height: 100 }]}
          value={detailedDescription}
          onChangeText={setDetailedDescription}
          multiline
        />
        <Text style={styles.label}>
          Latitude: {latitude || "Not available"}
        </Text>
        <Text style={styles.label}>
          Longitude: {longitude || "Not available"}
        </Text>
        <View style={styles.buttonContainer}>
          <Button title="Move North" onPress={() => movePoint("north")} />
          <Button title="Move South" onPress={() => movePoint("south")} />
          <Button title="Move East" onPress={() => movePoint("east")} />
          <Button title="Move West" onPress={() => movePoint("west")} />
        </View>
        {point.image && (
          <Image source={{ uri: point.image }} style={styles.image} />
        )}
        <Button title="Save" onPress={handleSave} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollViewContainer: {
    padding: 16,
    flexGrow: 1,
    justifyContent: "space-between",
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 8,
    marginBottom: 16,
    fontSize: 16,
    borderRadius: 4,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 16,
  },
  image: {
    width: 100,
    height: 100,
    marginBottom: 16,
    alignSelf: "center",
  },
});


----- File: screens/EquipmentScreen.js -----
import React from "react";
import { View, Text, Button, StyleSheet, Alert } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function EquipmentScreen({ character, setCharacter }) {
  const handleUnequipItem = async (slot) => {
    const item = character.inventory[slot];
    if (item) {
      Alert.alert("Unequip Item", `Opravdu chcete odvybavit ${item.name}?`, [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Odvybavit",
          onPress: async () => {
            // Remove item from the equipped slot
            const newInventory = [...character.inventory.items];
            newInventory.push({ ...item, equipped: false });

            const updatedCharacter = {
              ...character,
              inventory: {
                ...character.inventory,
                [slot]: null,
                items: newInventory,
              },
            };

            setCharacter(updatedCharacter);
            await AsyncStorage.setItem(
              "character",
              JSON.stringify(updatedCharacter)
            );

            Alert.alert(`${item.name} byl odvybaven a přesunut do inventáře.`);
          },
        },
      ]);
    }
  };

  const renderEquippedItem = (slot, label) => {
    const item = character.inventory[slot];
    if (!item) {
      return <Text style={styles.itemSlotText}>{label}: Žádný předmět</Text>;
    }

    let itemDetails = "";
    switch (item.type) {
      case "weapon":
        itemDetails = `Útok: +${item.properties.attackPoints}`;
        break;
      case "armor":
        itemDetails = `Obrana: +${item.properties.defensePoints}`;
        break;
      case "ring":
      case "amulet":
        itemDetails = `Efekt: +${item.properties.effectAmount}`;
        break;
      default:
        itemDetails = "";
    }

    return (
      <View style={styles.itemSlot}>
        <Text style={styles.itemSlotText}>
          {label}: {item.name} ({itemDetails})
        </Text>
        <Button title="Odvybavit" onPress={() => handleUnequipItem(slot)} />
      </View>
    );
  };

  return (
    <View style={styles.container}>
      {renderEquippedItem("head", "Hlava")}
      {renderEquippedItem("neck", "Krk")}
      {renderEquippedItem("body", "Tělo")}
      {renderEquippedItem("hands[0]", "Levá ruka")}
      {renderEquippedItem("hands[1]", "Pravá ruka")}
      {renderEquippedItem("legs", "Nohy")}
      {renderEquippedItem("feet", "Chodidla")}
      {character.inventory.fingers.map((ring, index) => (
        <View key={index}>
          {renderEquippedItem(`fingers[${index}]`, `Prst (${index + 1})`)}
        </View>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#f5f5f5",
  },
  itemSlot: {
    marginBottom: 20,
  },
  itemSlotText: {
    fontSize: 18,
    marginBottom: 10,
  },
});


----- File: screens/HomeScreen.js -----
import React, { useEffect, useState } from "react";
import { View, Text, Button, Alert, ImageBackground } from "react-native";
import styles from "../components/styles"; // Importování stylů
import { useFocusEffect } from "@react-navigation/native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function HomeScreen({ navigation }) {
  const [returnPointSet, setReturnPointSet] = useState(false);
  const [characterSummary, setCharacterSummary] = useState(null);

  useFocusEffect(
    React.useCallback(() => {
      checkReturnPoint();
      loadCharacterSummary();
    }, [])
  );

  const checkReturnPoint = async () => {
    try {
      const returnPoint = await AsyncStorage.getItem("returnPoint");
      setReturnPointSet(!!returnPoint);
    } catch (error) {
      console.error("Error reading return point from AsyncStorage:", error);
      setReturnPointSet(false);
    }
  };

  const loadCharacterSummary = async () => {
    try {
      const storedCharacter = await AsyncStorage.getItem("characters");
      if (storedCharacter) {
        const character = JSON.parse(storedCharacter)[0]; // Zobrazí se první postava
        setCharacterSummary({
          name: character.name,
          race: character.race,
          gender: character.gender || "", // Pokud není gender definován, nastaví se na prázdný řetězec
          characterClass: character.characterClass,
          level: character.level || 1,
        });
      }
    } catch (error) {
      console.error("Failed to load character summary", error);
    }
  };

  const setReturnPoint = async () => {
    showConfirmationDialog(
      "Set Return Point?",
      "Do you really want to set this location as your return point?",
      async () => {
        try {
          let { status } = await Location.requestForegroundPermissionsAsync();
          if (status !== "granted") {
            Alert.alert("Permission Denied", "Access to location was denied.");
            return;
          }
          let currentLocation = await Location.getCurrentPositionAsync({});
          const returnPoint = {
            latitude: currentLocation.coords.latitude,
            longitude: currentLocation.coords.longitude,
            title: "Return Point",
          };
          await AsyncStorage.setItem(
            "returnPoint",
            JSON.stringify(returnPoint)
          );
          console.log("Return point saved:", returnPoint);
          setReturnPointSet(true);
          Alert.alert("Saved", "Return point successfully saved!");
          navigation.navigate("Home");
        } catch (error) {
          console.error("Error setting return point:", error);
          Alert.alert("Error", "There was an error setting the return point.");
        }
      }
    );
  };

  const showConfirmationDialog = (title, message, onConfirm) => {
    Alert.alert(
      title,
      message,
      [
        {
          text: "Cancel",
          style: "cancel",
        },
        {
          text: "Yes",
          onPress: onConfirm,
        },
      ],
      { cancelable: true }
    );
  };

  return (
    <ImageBackground
      source={require("../assets/return.png")}
      style={styles.container}
    >
      <View style={styles.textContainer}>
        <Text style={[styles.title, { color: "#fff", fontSize: 28 }]}>
          Explore, Capture, and Never Get Lost Again
        </Text>
        <Text style={[styles.subtitle, { color: "#fff", fontSize: 20 }]}>
          Your personal map for mushroom hunting and other adventures
        </Text>
      </View>

      <View style={styles.buttonContainer}>
        <Button
          title="Set Return Point"
          onPress={setReturnPoint}
          disabled={returnPointSet}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Record Interest Point"
          onPress={() => navigation.navigate("Interest Point")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Actions"
          onPress={() => navigation.navigate("Actions Menu")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Map"
          onPress={() => navigation.navigate("DynamicMap")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View Photos"
          onPress={() => navigation.navigate("Photo Viewer")}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Settings"
          onPress={() => navigation.navigate("Settings")}
        />
      </View>

      {/* Zobrazení souhrnu postavy */}
      {characterSummary && (
        <View style={{ marginTop: 20 }}>
          <Text style={{ color: "#fff", fontSize: 18, textAlign: "center" }}>
            {characterSummary.name} {characterSummary.race}{" "}
            {characterSummary.gender ? characterSummary.gender.charAt(0) : ""}{" "}
            {characterSummary.characterClass} Lvl {characterSummary.level}
          </Text>
        </View>
      )}
    </ImageBackground>
  );
}


----- File: screens/InterestPointScreen.js -----
import React, { useState } from "react";
import * as FileSystem from "expo-file-system";
import {
  View,
  Text,
  Button,
  StyleSheet,
  Image,
  TextInput,
  Alert,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import * as Location from "expo-location";
import * as ImagePicker from "expo-image-picker";
import * as ImageManipulator from "expo-image-manipulator";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function InterestPointScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [image, setImage] = useState(null);
  const [description, setDescription] = useState("");
  const [detailedDescription, setDetailedDescription] = useState("");

  const getLocation = async () => {
    let { status } = await Location.requestForegroundPermissionsAsync();
    if (status !== "granted") {
      Alert.alert(
        "Permission denied",
        "Permission to access location was denied"
      );
      return;
    }

    let currentLocation = await Location.getCurrentPositionAsync({});
    setLocation({
      latitude: currentLocation.coords.latitude,
      longitude: currentLocation.coords.longitude,
    });
  };

  const pickImage = async () => {
    let result = await ImagePicker.launchCameraAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });

    if (!result.canceled) {
      const manipResult = await ImageManipulator.manipulateAsync(
        result.assets[0].uri,
        [],
        { compress: 0.5, format: ImageManipulator.SaveFormat.JPEG }
      );
      setImage(manipResult.uri);
    } else {
      Alert.alert(
        "No Image",
        "No image was selected or the operation was canceled."
      );
    }
  };

  const saveInterestPoint = async () => {
    if (!location) {
      Alert.alert("Missing Location", "Please set a location before saving.");
      return;
    }
    if (!image) {
      Alert.alert("Missing Image", "Please take a photo before saving.");
      return;
    }
    if (!description) {
      Alert.alert(
        "Missing Description",
        "Please enter a description before saving."
      );
      return;
    }

    try {
      const imageName = image.split("/").pop();
      const imagePath = `${FileSystem.documentDirectory}${imageName}`;

      await FileSystem.copyAsync({
        from: image,
        to: imagePath,
      });

      const interestPoint = {
        location,
        image: imagePath,
        description,
        detailedDescription, // Přidání detailního popisu
        timestamp: new Date().toISOString(),
      };

      const storedPoints = await AsyncStorage.getItem("interestPoints");
      const points = storedPoints ? JSON.parse(storedPoints) : [];

      points.push(interestPoint);

      await AsyncStorage.setItem("interestPoints", JSON.stringify(points));

      Alert.alert("Saved", "Interest point saved successfully!");

      navigation.navigate("Home");
    } catch (error) {
      console.error("Error saving interest point:", error);
      Alert.alert(
        "Error",
        "An error occurred while saving the interest point."
      );
    }
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
    >
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <Button title="Set Location" onPress={getLocation} />
        {location && (
          <Text style={styles.text}>
            Location: {location.latitude}, {location.longitude}
          </Text>
        )}
        <Button title="Take a Photo" onPress={pickImage} />
        {image && <Image source={{ uri: image }} style={styles.image} />}
        <TextInput
          style={styles.input}
          placeholder="Enter description"
          value={description}
          onChangeText={setDescription}
        />
        <TextInput
          style={[styles.input, { height: 80 }]}
          placeholder="Enter detailed description"
          value={detailedDescription}
          onChangeText={setDetailedDescription}
          multiline
        />
        <Button title="Save Interest Point" onPress={saveInterestPoint} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
  },
  scrollContainer: {
    alignItems: "center",
    padding: 16,
  },
  text: {
    marginVertical: 10,
    fontSize: 16,
  },
  image: {
    width: 200,
    height: 200,
    marginVertical: 10,
  },
  input: {
    height: 40,
    borderColor: "gray",
    borderWidth: 1,
    width: "100%",
    paddingHorizontal: 10,
    marginVertical: 10,
  },
});


----- File: screens/InventoryScreen.js -----
import React, { useState, useEffect } from "react";
import { View, Text, FlatList, Button, StyleSheet, Alert } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as Location from "expo-location";
import { equipItem } from "../utils/equipItem"; // Ujisti se, že tento import směřuje na správný soubor

export default function InventoryScreen({ navigation, character }) {
  // Předpokládám, že character je předáván jako prop
  const [inventory, setInventory] = useState([]);

  useEffect(() => {
    const loadInventory = async () => {
      try {
        const storedInventory = await AsyncStorage.getItem("inventory");
        setInventory(storedInventory ? JSON.parse(storedInventory) : []);
      } catch (error) {
        console.error("Error loading inventory:", error);
      }
    };
    loadInventory();
  }, []);

  const handleUseItem = (item) => {
    Alert.alert("Use Item", `You used ${item.name}`);
    // Zde můžete implementovat logiku pro použití předmětu
  };

  const handleRemoveItem = (item) => {
    Alert.alert(
      "Odstraň z inventáře",
      `Opravdu chcete odstranit ${item.name}?`,
      [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Odstraň z inventáře",
          onPress: async () => {
            const newInventory = inventory.filter(
              (invItem) => invItem.name !== item.name
            );
            setInventory(newInventory);
            await AsyncStorage.setItem(
              "inventory",
              JSON.stringify(newInventory)
            );

            // Get the current location of the player
            const location = await Location.getCurrentPositionAsync({});

            // Add the object back to placedObjects at the current location
            const storedObjects = await AsyncStorage.getItem("placedObjects");
            const placedObjects = storedObjects
              ? JSON.parse(storedObjects)
              : [];

            const discardedObject = {
              ...item,
              location: {
                latitude: location.coords.latitude,
                longitude: location.coords.longitude,
              },
            };

            placedObjects.push(discardedObject);
            await AsyncStorage.setItem(
              "placedObjects",
              JSON.stringify(placedObjects)
            );

            Alert.alert("Předmět odstraněn a vrácen zpět na mapu.");
          },
        },
      ]
    );
  };

  const handleEquipItem = (item) => {
    Alert.alert("Equip Item", `Opravdu chcete vybavit ${item.name}?`, [
      { text: "Zrušit", style: "cancel" },
      {
        text: "Vybavit",
        onPress: () => {
          equipItem(character, item); // Volání funkce pro vybavení předmětu
          Alert.alert(`${item.name} byl vybaven!`);
        },
      },
    ]);
  };

  const renderItem = ({ item }) => {
    let itemType = "";
    switch (item.type) {
      case "weapon":
        itemType = `W (Útok: +${item.properties.attackPoints})`;
        break;
      case "armor":
        itemType = `A (Obrana: +${item.properties.defensePoints})`;
        break;
      case "magicItem":
        itemType = `M (Efekt: +${item.properties.effectAmount})`;
        break;
      case "potion":
        itemType = `P (Efekt: +${item.properties.effectAmount} ${item.properties.effectType})`;
        break;
      case "scroll":
        itemType = `S (Kouzlo: ${item.properties.spellName})`;
        break;
      case "ring":
        itemType = `R (Efekt: +${item.properties.effectAmount})`;
        break;
      case "amulet":
        itemType = `N (Efekt: +${item.properties.effectAmount})`;
        break;
      default:
        itemType = "";
    }

    return (
      <View style={styles.itemContainer}>
        <Text style={styles.itemText}>
          {item.name} {itemType}
        </Text>
        <Text style={styles.itemDescription}>{item.description}</Text>
        <View style={styles.buttonContainer}>
          <Button title="Použít" onPress={() => handleUseItem(item)} />
          <Button title="Vybavit" onPress={() => handleEquipItem(item)} />
          <Button
            title="Odstraň z inventáře"
            onPress={() => handleRemoveItem(item)}
          />
        </View>
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={inventory}
        keyExtractor={(item) => item.name}
        renderItem={renderItem}
        ListEmptyComponent={
          <Text style={styles.emptyText}>Váš inventář je prázdný.</Text>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  itemContainer: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: "#ccc",
  },
  itemText: {
    fontSize: 18,
    fontWeight: "bold",
  },
  itemDescription: {
    fontSize: 14,
    color: "#666",
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 10,
  },
  emptyText: {
    textAlign: "center",
    marginTop: 20,
    fontSize: 16,
    color: "#999",
  },
});


----- File: screens/KompasScreen.js -----
import React, { useState, useEffect } from "react";
import { View, StyleSheet, Image, Text, Button } from "react-native";
import { Magnetometer } from "expo-sensors";
import * as Location from "expo-location";
export default function KompasScreen({ route }) {
  const { point } = route.params;
  const [heading, setHeading] = useState(0);
  const [location, setLocation] = useState(null);
  const [distance, setDistance] = useState(null);
  useEffect(() => {
    const getLocation = async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        return;
      }
      let loc = await Location.getCurrentPositionAsync({});
      setLocation(loc.coords);
      setDistance(
        calculateDistance(
          loc.coords.latitude,
          loc.coords.longitude,
          point.latitude,
          point.longitude
        )
      );
    };
    const _subscribe = () => {
      Magnetometer.addListener((data) => {
        let { x, y } = data;
        let angle = Math.atan2(y, x) * (180 / Math.PI);
        if (angle < 0) {
          angle += 360;
        }
        setHeading(Math.round(angle));
      });
    };
    getLocation();
    _subscribe();
    return () => {
      Magnetometer.removeAllListeners();
    };
  }, [location]);
  const calculateBearing = (lat1, lon1, lat2, lon2) => {
    const toRadians = (deg) => deg * (Math.PI / 180);
    const toDegrees = (rad) => rad * (180 / Math.PI);
    const φ1 = toRadians(lat1);
    const φ2 = toRadians(lat2);
    const Δλ = toRadians(lon2 - lon1);
    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x =
      Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
    let brng = toDegrees(Math.atan2(y, x));
    return (brng + 360) % 360;
  };
  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3; // Poloměr Země v metrech
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // Vzdálenost v metrech
  };
  if (!location) {
    return (
      <View style={styles.container}>
        <Text>Loading...</Text>
      </View>
    );
  }
  const bearing = calculateBearing(
    location.latitude,
    location.longitude,
    point.latitude,
    point.longitude
  );
  const direction = (bearing - heading + 360) % 360;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>
        Aktuální GPS: {location.latitude}, {location.longitude}
      </Text>
      <Text style={styles.text}>
        Cíl GPS: {point.latitude}, {point.longitude}
      </Text>
      <Text style={styles.text}>Směr k cíli: {Math.round(direction)}°</Text>
      <Text style={styles.text}>
        Vzdálenost: {(distance / 1000).toFixed(2)} km
      </Text>
      <Image
        source={require("../assets/arrow.png")} // cesta k obrázku šipky
        style={[styles.arrow, { transform: [{ rotate: `${direction}deg` }] }]}
      />
      <Button
        title="Open Compass App"
        onPress={() => {
          // Zde by byla funkce pro otevření nativní kompasové aplikace
        }}
      />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#f5f5f5",
  },
  text: {
    fontSize: 18,
    marginBottom: 10,
  },
  arrow: {
    width: 200,
    height: 200,
  },
  distanceText: {
    marginTop: 20,
    fontSize: 24,
    color: "#333",
  },
});


----- File: screens/PhotoViewerScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Image,
  Button,
  Alert,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import styles from "../components/styles"; // Import stylů
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as FileSystem from "expo-file-system";
import { Ionicons } from "@expo/vector-icons"; // Import ikon
export default function PhotoViewerScreen({ navigation }) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [points, setPoints] = useState([]);
  const [imageExists, setImageExists] = useState(true);
  useEffect(() => {
    const loadPoints = async () => {
      const storedPoints = await AsyncStorage.getItem("interestPoints");
      if (storedPoints) {
        const parsedPoints = JSON.parse(storedPoints);
        setPoints(parsedPoints);
        console.log("Loaded points:", parsedPoints);
      }
    };
    loadPoints();
  }, []);
  useEffect(() => {
    const checkImage = async () => {
      if (
        points.length > 0 &&
        points[currentIndex] &&
        points[currentIndex].image
      ) {
        const fileInfo = await FileSystem.getInfoAsync(
          points[currentIndex].image
        );
        console.log("Current image info:", fileInfo);
        if (!fileInfo.exists) {
          console.error("Image does not exist:", points[currentIndex].image);
          setImageExists(false);
        } else {
          console.log(
            "Image exists and will be displayed:",
            points[currentIndex].image
          );
          setImageExists(true);
        }
      }
    };
    checkImage();
  }, [currentIndex, points]);
  const handleNext = () => {
    setCurrentIndex((prevIndex) => (prevIndex + 1) % points.length);
  };
  const handlePrevious = () => {
    setCurrentIndex(
      (prevIndex) => (prevIndex - 1 + points.length) % points.length
    );
  };
  const handleDelete = async () => {
    Alert.alert(
      "Delete Point",
      "Are you sure you want to delete this point and its photo?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Yes",
          onPress: async () => {
            const updatedPoints = [...points];
            const [removedPoint] = updatedPoints.splice(currentIndex, 1);
            // Remove the image file from the file system if it exists
            if (removedPoint.image) {
              try {
                await FileSystem.deleteAsync(removedPoint.image);
                console.log("Image deleted:", removedPoint.image);
              } catch (error) {
                console.error("Error deleting image:", error);
              }
            }
            setPoints(updatedPoints);
            await AsyncStorage.setItem(
              "interestPoints",
              JSON.stringify(updatedPoints)
            );
            // If the last point was deleted, go back to the previous screen
            if (updatedPoints.length === 0) {
              navigation.goBack();
            } else if (currentIndex === updatedPoints.length) {
              setCurrentIndex(currentIndex - 1);
            }
          },
        },
      ],
      { cancelable: true }
    );
  };
  if (points.length === 0) {
    return (
      <View style={styles.container}>
        <Text style={styles.message}>No interest points found.</Text>
        <View style={styles.buttonContainer}>
          <Button title="Back" onPress={() => navigation.goBack()} />
        </View>
      </View>
    );
  }
  const currentPoint = points[currentIndex];
  return (
    <View style={styles.container}>
      {/* Přidání šipek nad fotkou */}
      <View style={localStyles.navigationContainer}>
        <TouchableOpacity
          onPress={handlePrevious}
          style={localStyles.navButton}
        >
          <Ionicons name="chevron-back-circle" size={30} color="black" />
          <Text style={localStyles.navText}>Previous</Text>
        </TouchableOpacity>
        <TouchableOpacity onPress={handleNext} style={localStyles.navButton}>
          <Text style={localStyles.navText}>Next</Text>
          <Ionicons name="chevron-forward-circle" size={30} color="black" />
        </TouchableOpacity>
      </View>
      {imageExists ? (
        <Image source={{ uri: currentPoint.image }} style={localStyles.image} />
      ) : (
        <Text>No image available</Text>
      )}
      <Text style={styles.text}>Description: {currentPoint.description}</Text>
      <Text style={styles.text}>
        Location: {currentPoint.location.latitude},{" "}
        {currentPoint.location.longitude}
      </Text>
      <View style={styles.buttonContainer}>
        <Button title="Delete Point" onPress={handleDelete} />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="View on Map"
          onPress={() =>
            navigation.navigate("DynamicMap", {
              selectedPoint: currentPoint,
              zoom: 15,
            })
          }
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Edit Point"
          onPress={() =>
            navigation.navigate("Edit Point", { point: currentPoint })
          }
        />
      </View>
    </View>
  );
}
// Lokální stylování pro šipky a obrázek
const localStyles = StyleSheet.create({
  navigationContainer: {
    flexDirection: "row",
    justifyContent: "space-between", // Rozmístí šipky do krajů
    alignItems: "center",
    marginBottom: 10, // Přidání mezery mezi šipkami a fotkou
    width: "100%",
    paddingHorizontal: 20, // Odsazení od okrajů obrazovky
  },
  navButton: {
    flexDirection: "row",
    alignItems: "center",
  },
  navText: {
    fontSize: 16,
    marginHorizontal: 5,
  },
  image: {
    width: "100%",
    height: 300,
    resizeMode: "contain",
    marginBottom: 10,
  },
});


----- File: screens/PlaceObjectScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Modal,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Keyboard,
  TouchableWithoutFeedback,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Picker } from "@react-native-picker/picker"; // Import Pickeru

export default function PlaceObjectScreen({ navigation }) {
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [type, setType] = useState("weapon"); // Default type is weapon
  const [slot, setSlot] = useState("body"); // Default slot for armor is body
  const [properties, setProperties] = useState({});
  const [modalVisible, setModalVisible] = useState(false);

  const handlePlaceObject = async () => {
    try {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        alert("Permission to access location was denied");
        return;
      }
      const location = await Location.getCurrentPositionAsync({});
      const newObject = {
        name,
        description,
        type,
        slot, // Slot specification added here
        properties, // Specific properties of the object
        location: {
          latitude: location.coords.latitude,
          longitude: location.coords.longitude,
        },
      };
      const storedObjects = await AsyncStorage.getItem("placedObjects");
      const placedObjects = storedObjects ? JSON.parse(storedObjects) : [];
      placedObjects.push(newObject);
      await AsyncStorage.setItem(
        "placedObjects",
        JSON.stringify(placedObjects)
      );
      alert("Object placed successfully!");
      navigation.goBack();
    } catch (error) {
      console.error("Error placing object:", error);
      alert("There was an error placing the object.");
    }
  };

  const objectTypes = [
    { label: "Weapon", value: "weapon" },
    { label: "Armor", value: "armor" },
    { label: "Magic Item", value: "magicItem" },
    { label: "Potion", value: "potion" },
    { label: "Food", value: "food" },
    { label: "Scroll", value: "scroll" },
    { label: "Sign", value: "sign" },
    { label: "Dungeon", value: "dungeon" }, // Place of battle
  ];

  const armorSlots = [
    { label: "Head", value: "head" },
    { label: "Neck", value: "neck" },
    { label: "Body", value: "body" },
    { label: "Legs", value: "legs" },
    { label: "Feet", value: "feet" },
    { label: "Left Hand", value: "leftHand" },
    { label: "Right Hand", value: "rightHand" },
  ];

  const handleTypeChange = (selectedType) => {
    setType(selectedType);
    setProperties({});
    if (selectedType === "armor") {
      setSlot("body"); // Default to body slot for armor
    } else {
      setSlot(null);
    }
  };

  const handlePropertyChange = (property, value) => {
    setProperties((prevProperties) => ({
      ...prevProperties,
      [property]: value,
    }));
  };

  const renderPropertiesInput = () => {
    switch (type) {
      case "weapon":
        return (
          <>
            <Text style={styles.label}>One-Handed/Two-Handed:</Text>
            <Picker
              selectedValue={properties.handType}
              onValueChange={(value) => handlePropertyChange("handType", value)}
            >
              <Picker.Item label="One-Handed" value="oneHanded" />
              <Picker.Item label="Two-Handed" value="twoHanded" />
            </Picker>

            <Text style={styles.label}>Attack Points:</Text>
            <Picker
              selectedValue={properties.attackPoints}
              onValueChange={(value) =>
                handlePropertyChange("attackPoints", value)
              }
            >
              {[...Array(21).keys()].map((val) => (
                <Picker.Item key={val} label={`${val}`} value={val} />
              ))}
            </Picker>

            <Text style={styles.label}>Weight:</Text>
            <Picker
              selectedValue={properties.weight}
              onValueChange={(value) => handlePropertyChange("weight", value)}
            >
              {[...Array(51).keys()].map((val) => (
                <Picker.Item key={val} label={`${val}`} value={val} />
              ))}
            </Picker>
          </>
        );
      case "armor":
        return (
          <>
            <Text style={styles.label}>Defense Points:</Text>
            <Picker
              selectedValue={properties.defensePoints}
              onValueChange={(value) =>
                handlePropertyChange("defensePoints", value)
              }
            >
              {[...Array(21).keys()].map((val) => (
                <Picker.Item key={val} label={`${val}`} value={val} />
              ))}
            </Picker>

            <Text style={styles.label}>Weight:</Text>
            <Picker
              selectedValue={properties.weight}
              onValueChange={(value) => handlePropertyChange("weight", value)}
            >
              {[...Array(51).keys()].map((val) => (
                <Picker.Item key={val} label={`${val}`} value={val} />
              ))}
            </Picker>

            <Text style={styles.label}>Select Armor Slot:</Text>
            <Picker
              selectedValue={slot}
              onValueChange={(value) => setSlot(value)}
            >
              {armorSlots.map((slot) => (
                <Picker.Item
                  key={slot.value}
                  label={slot.label}
                  value={slot.value}
                />
              ))}
            </Picker>
          </>
        );
      case "potion":
        return (
          <>
            <Text style={styles.label}>Potion Effect:</Text>
            <Picker
              selectedValue={properties.effectType}
              onValueChange={(value) =>
                handlePropertyChange("effectType", value)
              }
            >
              <Picker.Item label="Health" value="health" />
              <Picker.Item label="Mana" value="mana" />
              <Picker.Item label="Luck" value="luck" />
              <Picker.Item label="Attack" value="attack" />
              <Picker.Item label="Defense" value="defense" />
              <Picker.Item label="Speed" value="speed" />
            </Picker>

            <Text style={styles.label}>Effect Amount:</Text>
            <Picker
              selectedValue={properties.effectAmount}
              onValueChange={(value) =>
                handlePropertyChange("effectAmount", value)
              }
            >
              {[...Array(71).keys()].map((val) => (
                <Picker.Item
                  key={val - 20}
                  label={`${val - 20}`}
                  value={val - 20}
                />
              ))}
            </Picker>

            <Text style={styles.label}>Duration (in minutes):</Text>
            <Picker
              selectedValue={properties.duration}
              onValueChange={(value) => handlePropertyChange("duration", value)}
            >
              {[...Array(61).keys()].map((val) => (
                <Picker.Item key={val} label={`${val}`} value={val} />
              ))}
            </Picker>
          </>
        );
      case "dungeon":
        return (
          <>
            <Text style={styles.label}>Dungeon Difficulty:</Text>
            <Picker
              selectedValue={properties.difficulty}
              onValueChange={(value) =>
                handlePropertyChange("difficulty", value)
              }
            >
              <Picker.Item label="Easy" value="easy" />
              <Picker.Item label="Medium" value="medium" />
              <Picker.Item label="Hard" value="hard" />
            </Picker>
          </>
        );
      default:
        return null;
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <Text style={styles.label}>Object Name:</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Enter object name"
        />
        <Text style={styles.label}>Object Description:</Text>
        <TextInput
          style={styles.input}
          value={description}
          onChangeText={setDescription}
          placeholder="Enter object description"
          multiline
        />
        <Text style={styles.label}>Object Type:</Text>
        <TouchableOpacity
          style={styles.picker}
          onPress={() => setModalVisible(true)}
        >
          <Text>{objectTypes.find((item) => item.value === type)?.label}</Text>
        </TouchableOpacity>

        <Modal
          animationType="slide"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => setModalVisible(!modalVisible)}
        >
          <View style={styles.modalView}>
            {objectTypes.map((item) => (
              <TouchableOpacity
                key={item.value}
                style={styles.modalItem}
                onPress={() => {
                  handleTypeChange(item.value);
                  setModalVisible(false);
                }}
              >
                <Text>{item.label}</Text>
              </TouchableOpacity>
            ))}
            <Button title="Cancel" onPress={() => setModalVisible(false)} />
          </View>
        </Modal>

        {renderPropertiesInput()}

        <Button title="Place Object" onPress={handlePlaceObject} />
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#fff",
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  input: {
    height: 40,
    borderColor: "#ccc",
    borderWidth: 1,
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  picker: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
  },
  modalView: {
    margin: 20,
    backgroundColor: "white",
    borderRadius: 20,
    padding: 35,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  modalItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#ddd",
    width: "100%",
    textAlign: "center",
  },
});


----- File: screens/ReturnPointScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  ActivityIndicator,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";
export default function ReturnPointScreen({ navigation }) {
  const [location, setLocation] = useState(null);
  const [loading, setLoading] = useState(false);
  const [errorMsg, setErrorMsg] = useState(null);
  useEffect(() => {
    loadReturnPoint();
  }, []);
  const getLocation = async () => {
    try {
      setLoading(true);
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        console.log("Permission to access location was denied");
        setErrorMsg("Permission to access location was denied");
        setLoading(false);
        return;
      }
      let currentLocation = await Location.getCurrentPositionAsync({});
      const newLocation = {
        latitude: currentLocation.coords.latitude,
        longitude: currentLocation.coords.longitude,
      };
      setLocation(newLocation);
      await AsyncStorage.setItem("returnPoint", JSON.stringify(newLocation));
      setLoading(false);
    } catch (error) {
      console.error("Error getting location:", error);
      setErrorMsg("Error getting location");
      setLoading(false);
    }
  };
  const loadReturnPoint = async () => {
    try {
      const savedLocation = await AsyncStorage.getItem("returnPoint");
      if (savedLocation) {
        setLocation(JSON.parse(savedLocation));
      }
    } catch (error) {
      console.error("Error loading return point:", error);
      setErrorMsg("Error loading return point");
    }
  };
  if (loading || !location) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#0000ff" />
        <Text>{loading ? "Setting return point..." : "Loading map..."}</Text>
        {errorMsg ? <Text>{errorMsg}</Text> : null}
      </View>
    );
  }
  const leafletHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
      <style>
        #map {
          width: 100%;
          height: 100vh;
        }
      </style>
    </head>
    <body>
      <div id="map"></div>
      <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
      <script>
        var map = L.map('map').setView([${location.latitude}, ${location.longitude}], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors'
        }).addTo(map);
        var marker = L.marker([${location.latitude}, ${location.longitude}]).addTo(map);
        marker.bindPopup("<b>Return Point</b><br>This is your return point.").openPopup();
      </script>
    </body>
    </html>
  `;
  return (
    <View style={styles.container}>
      <Button title="Set Return Point" onPress={getLocation} />
      <View style={styles.mapContainer}>
        <WebView
          originWhitelist={["*"]}
          source={{ html: leafletHtml }}
          style={styles.map}
        />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  text: {
    marginVertical: 10,
    fontSize: 16,
  },
  mapContainer: {
    width: "100%",
    height: "80%",
    marginTop: 10,
  },
  map: {
    flex: 1,
  },
});


----- File: screens/SearchAreaScreen.js -----
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  Button,
  StyleSheet,
  ScrollView,
  Alert,
  TouchableWithoutFeedback,
  Keyboard,
} from "react-native";
import * as Location from "expo-location";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function SearchAreaScreen({ navigation }) {
  const [foundObjects, setFoundObjects] = useState([]);
  const [character, setCharacter] = useState(null); // Přidáme state pro charakter

  useEffect(() => {
    const searchArea = async () => {
      try {
        let { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== "granted") {
          alert("Permission to access location was denied");
          return;
        }

        const location = await Location.getCurrentPositionAsync({});
        const storedObjects = await AsyncStorage.getItem("placedObjects");
        const placedObjects = storedObjects ? JSON.parse(storedObjects) : [];

        const nearbyObjects = placedObjects.filter(
          (obj) =>
            getDistance(
              obj.location.latitude,
              obj.location.longitude,
              location.coords.latitude,
              location.coords.longitude
            ) <= 5
        );

        if (nearbyObjects.length > 0) {
          setFoundObjects(nearbyObjects);
        } else {
          setFoundObjects([]);
        }

        // Použití stejné logiky pro nalezení aktivní postavy
        const storedCharacters = await AsyncStorage.getItem("characters");
        if (storedCharacters) {
          const characters = JSON.parse(storedCharacters);
          const activeCharacter = characters.find((char) => char.isActive);
          if (activeCharacter) {
            setCharacter(activeCharacter); // Uložení aktivní postavy do stavu
            console.log("Active character loaded:", activeCharacter);
          } else {
            Alert.alert(
              "No active character",
              "Please select or create a character."
            );
            navigation.goBack();
          }
        } else {
          Alert.alert(
            "No characters found",
            "Please create a character first."
          );
          navigation.goBack();
        }
      } catch (error) {
        console.error("Error searching area or loading character:", error);
      }
    };
    searchArea();
  }, []);

  const getDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3; // Radius of the Earth in meters
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon1 - lon2) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  const handleSaveToInventory = async (object) => {
    try {
      if (!character) {
        console.log("Character not found in handleSaveToInventory");
        throw new Error(
          "No character found. Please select or create a character."
        );
      }

      const storedInventory = await AsyncStorage.getItem("inventory");
      const inventory = storedInventory ? JSON.parse(storedInventory) : [];

      // Ujistěte se, že character.inventory existuje a je inicializován
      if (!character.inventory) {
        character.inventory = {};
      }

      // Ujistěte se, že podvlastnost 'hands' existuje a je inicializována
      if (!character.inventory.hands) {
        character.inventory.hands = [null, null];
      }

      const currentWeapon = character.inventory.hands[0]; // Assuming main hand
      const currentArmor = character.inventory.body;

      let shouldOfferSwap = false;
      if (
        object.type === "weapon" &&
        (!currentWeapon ||
          object.properties.attackPoints >
            currentWeapon.properties.attackPoints)
      ) {
        shouldOfferSwap = true;
      } else if (
        object.type === "armor" &&
        (!currentArmor ||
          object.properties.defensePoints >
            currentArmor.properties.defensePoints)
      ) {
        shouldOfferSwap = true;
      }

      if (shouldOfferSwap) {
        Alert.alert(
          "New item found!",
          `Hmm, this ${object.name} seems better than my current equipment. Should I equip it?`,
          [
            { text: "No, keep current equipment", style: "cancel" },
            {
              text: "Yes, equip it",
              onPress: async () => {
                // Move current item to general inventory
                if (object.type === "weapon" && currentWeapon) {
                  currentWeapon.equipped = false;
                  inventory.push(currentWeapon);
                } else if (object.type === "armor" && currentArmor) {
                  currentArmor.equipped = false;
                  inventory.push(currentArmor);
                }

                // Equip new item
                object.equipped = true;
                inventory.push(object);
                character.inventory.hands[0] = object; // Example of equipping a weapon
                await AsyncStorage.setItem(
                  "inventory",
                  JSON.stringify(inventory)
                );
                await AsyncStorage.setItem(
                  "activeCharacter",
                  JSON.stringify(character)
                );

                // Remove the object from placedObjects in AsyncStorage
                const storedObjects = await AsyncStorage.getItem(
                  "placedObjects"
                );
                let placedObjects = storedObjects
                  ? JSON.parse(storedObjects)
                  : [];

                // Filter out the object that has been picked up
                placedObjects = placedObjects.filter(
                  (obj) =>
                    obj.name !== object.name ||
                    obj.location.latitude !== object.location.latitude ||
                    obj.location.longitude !== object.location.longitude
                );

                // Update placedObjects in AsyncStorage
                await AsyncStorage.setItem(
                  "placedObjects",
                  JSON.stringify(placedObjects)
                );

                // Update the state to remove the object from the UI
                setFoundObjects(placedObjects);

                alert(
                  `${object.name} equipped, saved to inventory, and removed from the map!`
                );
              },
            },
          ]
        );
      } else {
        // Standard inventory save logic
        inventory.push(object);
        await AsyncStorage.setItem("inventory", JSON.stringify(inventory));

        // Remove the object from placedObjects in AsyncStorage
        const storedObjects = await AsyncStorage.getItem("placedObjects");
        let placedObjects = storedObjects ? JSON.parse(storedObjects) : [];

        // Filter out the object that has been picked up
        placedObjects = placedObjects.filter(
          (obj) =>
            obj.name !== object.name ||
            obj.location.latitude !== obj.location.latitude ||
            obj.location.longitude !== obj.location.longitude
        );

        // Update placedObjects in AsyncStorage
        await AsyncStorage.setItem(
          "placedObjects",
          JSON.stringify(placedObjects)
        );

        // Update the state to remove the object from the UI
        setFoundObjects(placedObjects);

        alert(`${object.name} saved to inventory and removed from the map!`);
      }
    } catch (error) {
      console.error("Error saving to inventory:", error);
      alert("There was an error saving the object to your inventory.");
    }
  };

  const handleEnterDungeon = (dungeon) => {
    navigation.navigate("DungeonScreen", { dungeon });
  };

  const handleUnlockObject = async (lockObject) => {
    try {
      const storedInventory = await AsyncStorage.getItem("inventory");
      const inventory = storedInventory ? JSON.parse(storedInventory) : [];
      const hasKey = inventory.some(
        (item) => item.type === "key" && item.unlocks === lockObject.name
      );
      if (hasKey) {
        alert(`${lockObject.name} unlocked!`);
        // Implement your unlock logic here
      } else {
        alert(`You need a key to unlock ${lockObject.name}.`);
      }
    } catch (error) {
      console.error("Error unlocking object:", error);
      alert("There was an error unlocking the object.");
    }
  };

  const handleSaveToBook = async (object) => {
    try {
      const storedEntries = await AsyncStorage.getItem("bookEntries");
      const bookEntries = storedEntries ? JSON.parse(storedEntries) : [];
      bookEntries.push(object);
      await AsyncStorage.setItem("bookEntries", JSON.stringify(bookEntries));
      alert(`${object.name} saved to your book!`);
    } catch (error) {
      console.error("Error saving to book:", error);
      alert("There was an error saving the object to your book.");
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        {character && (
          <View style={styles.characterContainer}>
            <Text style={styles.characterName}>
              Active Character: {character.name}
            </Text>
            <Text>Class: {character.characterClass}</Text>
            <Text>Level: {character.level}</Text>
          </View>
        )}
        {foundObjects.length > 0 ? (
          <ScrollView>
            {foundObjects.map((object, index) => (
              <View key={index} style={styles.objectContainer}>
                <Text style={styles.label}>You found:</Text>
                <Text style={styles.objectName}>{object.name}</Text>
                <Text style={styles.objectDescription}>
                  {object.description}
                </Text>

                {object.type === "dungeon" ? (
                  <Button
                    title="Enter Dungeon"
                    onPress={() => handleEnterDungeon(object)}
                  />
                ) : object.type === "lock" ? (
                  <Button
                    title="Unlock"
                    onPress={() => handleUnlockObject(object)}
                  />
                ) : object.type === "sign" ? (
                  <Button
                    title="Save to Book"
                    onPress={() => handleSaveToBook(object)}
                  />
                ) : (
                  <Button
                    title="Save to Inventory"
                    onPress={() => handleSaveToInventory(object)}
                  />
                )}
              </View>
            ))}
          </ScrollView>
        ) : (
          <Text style={styles.label}>Nothing found in the area.</Text>
        )}
        <Button title="Back" onPress={() => navigation.goBack()} />
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    justifyContent: "center",
    alignItems: "center",
  },
  characterContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
    alignItems: "center",
  },
  characterName: {
    fontSize: 20,
    fontWeight: "bold",
  },
  objectContainer: {
    marginBottom: 20,
    padding: 10,
    borderColor: "#ccc",
    borderWidth: 1,
    borderRadius: 5,
  },
  label: {
    fontSize: 18,
    marginBottom: 8,
  },
  objectName: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 8,
  },
  objectDescription: {
    fontSize: 16,
    marginBottom: 16,
  },
});


----- File: screens/SettingsScreen.js -----
import React, { useState } from "react";
import {
  View,
  Text,
  Button,
  Alert,
  TouchableOpacity,
  Linking,
  StyleSheet,
} from "react-native";
import { Picker } from "@react-native-picker/picker";
import styles from "../components/styles";
import { importData } from "../components/importData";
import { exportData } from "../components/exportData";
import AsyncStorage from "@react-native-async-storage/async-storage";

export default function SettingsScreen({ navigation }) {
  const [selectedMode, setSelectedMode] = useState("Herní režim");
  const [loading, setLoading] = useState(false);

  const handleModeChange = (mode) => {
    setSelectedMode(mode);
    Alert.alert("Režim změněn", `Aktuální režim je nyní: ${mode}`);
  };

  const deleteAllData = async () => {
    Alert.alert(
      "Smazat všechna data?",
      "Opravdu chcete smazat všechna data? Tato akce je nevratná.",
      [
        { text: "Zrušit", style: "cancel" },
        {
          text: "Ano",
          onPress: async () => {
            try {
              await AsyncStorage.clear();
              Alert.alert("Úspěch", "Všechna data byla smazána.");
            } catch (error) {
              Alert.alert("Chyba", "Došlo k chybě při mazání dat.");
              console.error("Delete error:", error);
            }
          },
        },
      ],
      { cancelable: true }
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Settings</Text>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Mode Settings</Text>
        <View style={styles.pickerContainer}>
          <Picker
            selectedValue={selectedMode}
            style={styles.picker}
            onValueChange={(itemValue) => handleModeChange(itemValue)}
          >
            <Picker.Item label="Herní režim" value="Herní režim" />
            <Picker.Item label="Výletní režim" value="Výletní režim" />
            <Picker.Item label="Admin režim" value="Admin režim" />
          </Picker>
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Data Management</Text>
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Export Data"
          onPress={() => exportData(setLoading)}
          disabled={loading}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Import Data"
          onPress={() => importData(setLoading)}
          disabled={loading}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button title="Delete All Data" onPress={deleteAllData} />
      </View>

      <View style={styles.buttonContainer}>
        <Button title="About" onPress={() => navigation.navigate("About")} />
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={localStyles.aboutButton}
          onPress={() =>
            Linking.openURL("https://www.facebook.com/groups/461720089986492")
          }
        >
          <Text style={localStyles.aboutButtonText}>
            VentureOut Facebook Group
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

// Přidání stylů pro tlačítko About
const localStyles = StyleSheet.create({
  aboutButton: {
    backgroundColor: "#007bff",
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 5,
    marginTop: 10,
  },
  aboutButtonText: {
    color: "white",
    fontWeight: "bold",
    textAlign: "center",
  },
});


===== Directory: data =====
----- File: data/CharacterAttributes.js -----
const CharacterAttributes = {
  genderModifiers: {
    Male: {
      strength: 1,
      speed: 0,
      agility: 0,
    },
    Female: {
      strength: -1,
      speed: 1,
      agility: 1,
    },
  },
};

export default CharacterAttributes;


----- File: data/CharacterClasses.js -----
const CharacterClasses = {
  Warrior: {
    name: "Warrior",
    description: "A strong and brave fighter, skilled in melee combat.",
    strength: 3,
    defense: 2,
    attack: 2,
    speed: 0,
    mana: -10,
    health: 20,
  },
  Mage: {
    name: "Mage",
    description: "A master of the arcane, powerful in magic.",
    strength: 0,
    defense: 0,
    attack: 1,
    speed: 0,
    mana: 30,
    health: -10,
  },
  Rogue: {
    name: "Rogue",
    description: "A stealthy and agile character, skilled in evasion.",
    strength: 1,
    defense: 0,
    attack: 2,
    speed: 3,
    mana: 0,
    health: 0,
  },
};

export default CharacterClasses;


----- File: data/Races.js -----
const Races = {
  Human: {
    name: "Human",
    description: "Versatile and adaptable, humans can excel in various roles.",
    strength: 10,
    defense: 10,
    attack: 10,
    speed: 10,
    luck: 10,
    courage: 10,
  },
  Elf: {
    name: "Elf",
    description:
      "Graceful and intelligent, elves are adept at magic and archery.",
    strength: 8,
    defense: 7,
    attack: 12,
    speed: 12,
    luck: 15,
    courage: 8,
  },
  Dwarf: {
    name: "Dwarf",
    description:
      "Stout and sturdy, dwarves are masters of mining and smithing.",
    strength: 14,
    defense: 15,
    attack: 10,
    speed: 6,
    luck: 8,
    courage: 12,
  },
  Orc: {
    name: "Orc",
    description: "Powerful and fierce, orcs thrive in battle.",
    strength: 15,
    defense: 12,
    attack: 14,
    speed: 7,
    luck: 5,
    courage: 14,
  },
};

export default Races;


===== Directory: utils =====
----- File: utils/equipItem.js -----
import { getCharacter } from "../models/characterModel";
import CharacterInventory from "../models/CharacterInventory";

export const equipItem = async (item) => {
  const character = await getCharacter();

  if (!character) {
    console.error("Character is undefined or null.");
    return;
  }

  // Inicializace inventáře, pokud neexistuje
  if (!character.inventory) {
    console.warn("Inventory is undefined, initializing default inventory.");
    character.inventory = new CharacterInventory();
  } else {
    character.inventory = CharacterInventory.fromObject(character.inventory);
  }

  character.inventory.equipItem(item);

  updateCharacterStats(character);

  await AsyncStorage.setItem("activeCharacter", JSON.stringify(character));
};

const updateCharacterStats = (character) => {
  let attack = 0;
  let defense = 0;

  if (character.inventory.hands[0]) {
    attack += character.inventory.hands[0].properties.attackPoints || 0;
  }
  if (character.inventory.hands[1]) {
    attack += character.inventory.hands[1].properties.attackPoints || 0;
  }
  if (character.inventory.body) {
    defense += character.inventory.body.properties.defensePoints || 0;
  }
  if (character.inventory.head) {
    defense += character.inventory.head.properties.defensePoints || 0;
  }
  if (character.inventory.neck) {
    defense += character.inventory.neck.properties.defensePoints || 0;
  }
  if (character.inventory.legs) {
    defense += character.inventory.legs.properties.defensePoints || 0;
  }
  if (character.inventory.feet) {
    defense += character.inventory.feet.properties.defensePoints || 0;
  }

  character.stats.attack = attack;
  character.stats.defense = defense;
};


----- File: utils/generateEnemy.js -----
import Creature from "../models/Creature";
import CreatureTypes from "../models/CreatureTypes";

export function generateEnemy(
  playerLevel,
  difficulty = "Medium",
  environment = "Cave"
) {
  const selectedType = CreatureTypes[difficulty];

  if (!selectedType) {
    console.error(`No creature types found for difficulty: ${difficulty}`);
    return null;
  }

  const possibleCreatures = Object.values(selectedType).filter((creature) =>
    creature.environments.includes(environment)
  );

  if (possibleCreatures.length === 0) {
    console.error(`No creatures found for environment: ${environment}`);
    return null;
  }

  const selectedCreature =
    possibleCreatures[Math.floor(Math.random() * possibleCreatures.length)];

  const levelAdjustment =
    difficulty === "Weak" ? -1 : difficulty === "Strong" ? 1 : 0;
  const enemyLevel = Math.max(1, playerLevel + levelAdjustment);

  return new Creature(
    selectedCreature.name,
    selectedCreature.type,
    enemyLevel,
    selectedCreature.baseHealth + enemyLevel * 10,
    selectedCreature.baseAttack + enemyLevel * 2,
    selectedCreature.baseDefense + enemyLevel * 2,
    selectedCreature.baseSpeed,
    selectedCreature.abilities,
    environment
  );
}


